#!/usr/bin/env python
#
# Copyright (C) 2017  Qi Chu adapted from gstlal_inspiral_plotsummary
# Copyright (C) 2009-2013  Kipp Cannon, Chad Hanna, Drew Keppel
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

## @file
# A program to produce a variety of plots from a gstlal inspiral analysis, e.g. IFAR plots, missed found, etc.

#
# =============================================================================
#
#								   Preamble
#
# =============================================================================
#

import math
import matplotlib

matplotlib.rcParams.update({
    "font.size": 16.0,
    "axes.titlesize": 14.0,
    "axes.labelsize": 14.0,
    "xtick.labelsize": 13.0,
    "ytick.labelsize": 13.0,
    "legend.fontsize": 10.0,
    "figure.dpi": 300,
    "savefig.dpi": 300,
    "text.usetex": True,
    "path.simplify": True
})
from matplotlib import figure
from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas
from scipy import stats as scipy_stats
import numpy
from optparse import OptionParser
import sqlite3
import sys
import os
import re
import operator
import itertools
import subprocess

from glue import segments
from glue.ligolw import dbtables
from glue.ligolw import lsctables
from glue.ligolw.utils import segments as ligolw_segments
from glue import lal
from lal import LIGOTimeGPS

from gstlal.pipemodules.postcohtable import postcoh_table_def
from gstlal.workflow.utils import T050017_filename
from gstlal import gviz_api
import pdb


def to_google_json(fname, description, data):
    json = open(fname, "w")
    data_table = gviz_api.DataTable(description)
    data_table.LoadData(data)
    print >> json, data_table.ToJSon()
    json.close()


class SimInspiral(lsctables.SimInspiral):
    @property
    def mtotal(self):
        return self.mass1 + self.mass2

    @property
    def chi(self):
        return (self.mass1 * self.spin1z +
                self.mass2 * self.spin2z) / self.mtotal

    def get_exp_snr(self, instrument):
        if instrument == "H1":
            return self.alpha4
        if instrument == "L1":
            return self.alpha5
        if instrument == "V1":
            return self.alpha6
        return 0.0


class PostcohInspiral(postcoh_table_def.PostcohInspiral):
    @property
    def chi(self):
        return (self.mass1 * self.spin1z +
                self.mass2 * self.spin2z) / self.mtotal

    def get_effective_snr(self, fac):
        return self.snr / (self.chisq / self.chisq_dof)**.5

    def get_ifo_endtime(self, instrument):
        end_time = getattr(self, "end_time_sngl_%s" % instrument)
        end_time_ns = getattr(self, "end_time_ns_sngl_%s" % instrument)
        return LIGOTimeGPS(end_time, end_time_ns)

    def get_eff_distance(self, instrument):
        return getattr(self, "deff_%s" % instrument)

    def get_snglsnr(self, instrument):
        return getattr(self, "snglsnr_%s" % instrument)


lsctables.LIGOTimeGPS = LIGOTimeGPS
lsctables.SimInspiralTable.RowType = SimInspiral
postcoh_table_def.PostcohInspiralDBTable.RowType = PostcohInspiral

__author__ = "Kipp Cannon <kipp.cannon@ligo.org>, Chad Hanna <channa@ligo.caltech.edu>"
__version__ = "some version"

#
# =============================================================================
#
#								 Command Line
#
# =============================================================================
#


def parse_command_line():
    parser = OptionParser(version="Name: %%prog\n%s" % ""  # FIXME
                          )
    parser.add_option("--noninj-database",
                      metavar="noninj-database",
                      default=None,
                      help="noninj database.")
    parser.add_option("--background-xml",
                      metavar="background-histogram-xml",
                      default=None,
                      help="background histogram xml.")
    parser.add_option("--shift-database",
                      metavar="shift-database",
                      default=None,
                      help="shifted database.")
    parser.add_option("--inj-database",
                      metavar="inj-database",
                      default=None,
                      help="one or multiple inj database.")
    parser.add_option(
        "--noninj-user-tag",
        metavar="user-tag",
        default="ALL",
        help="Set the prefix for output filenames (default = \"ALL\").")
    parser.add_option(
        "--shift-user-tag",
        metavar="user-tag",
        default="ALL",
        help="Set the prefix for output filenames (default = \"ALL\").")
    parser.add_option(
        "--inj-user-tag",
        metavar="user-tag",
        default="ALL",
        help="Set the prefix for output filenames (default = \"ALL\").")
    parser.add_option("--output-dir",
                      metavar="output-dir",
                      default=".",
                      help="Provide an output directory")
    parser.add_option(
        "-f",
        "--format",
        metavar="{\"png\",\"pdf\",\"svg\",\"eps\",...}",
        action="append",
        default=[],
        help=
        "Set the output image format.  Can be given multiple times (default = \"png\")."
    )
    parser.add_option(
        "--segments-name",
        metavar="name",
        default="statevectorsegments",
        help=
        "Set the name of the segments that were analyzed (default = \"statevectorsegments\")."
    )
    parser.add_option(
        "--vetoes-name",
        metavar="name",
        default="vetoes",
        help="Set the name of the veto segments (default = \"vetoes\").")
    parser.add_option(
        "--ifos",
        metavar="ifo-names",
        default="H1L1",
        help="Set the IFO data processed in the run (default = \"H1L1\").")
    parser.add_option(
        "--background-ifos",
        metavar="ifo-names",
        default="H1L1",
        help=
        "Set the IFO data used for background collection (default = \"H1L1\")."
    )
    parser.add_option(
        "--plot-group",
        metavar="number",
        action="append",
        default=None,
        help=
        """Generate the given plot group.  Can be given multiple times (default = make all plot groups)
 0. Segments Table (Analytical time)
 1. Summary Table (top 10 loudest events globally across all zero lag triggers read in)
 2. Missed Found (Scatter plots of missed and found injections on several axes)
 3. Injection Parameter Accuracy Plots
 4. Background Vs Injection Plots (sngl detector triggers from coincs of snr, chisq, bank chisq,...)
 5. Background Vs Injection Plots pairwise (effective snr DET1 Vs. DET2...),
 6. Rate Vs Threshold (SNR histograms, IFAR histograms, ...)
 7. Injection Parameter Distribution Plots (The input parameters that went into inspinj, like mass1 vs mass2...)
 8. Background Distribution Plots (The input parameters that went into inspinj, like mass1 vs mass2...)
""")
    parser.add_option(
        "--far-threshold",
        metavar="Hz",
        default=1. / (30 * 86400),
        type="float",
        help=
        "Set the FAR threshold for found injections (default = 1 / 30 days).")
    parser.add_option("--njob",
                      metavar="N",
                      default=1,
                      type="int",
                      help="Number of jobs launched.")
    parser.add_option(
        "-t",
        "--tmp-space",
        metavar="path",
        help=
        "Path to a directory suitable for use as a work area while manipulating the database file.  The database file will be worked on in this directory, and then moved to the final location when complete.  This option is intended to improve performance when running in a networked environment, where there might be a local disk with higher bandwidth than is available to the filesystem on which the final output will reside."
    )
    parser.add_option("-v",
                      "--verbose",
                      action="store_true",
                      help="Be verbose.")
    options, filenames = parser.parse_args()

    if options.plot_group is not None:
        options.plot_group = sorted(map(int, options.plot_group))
    if not options.format:
        options.format = ["png"]

        if options.noninj_database is not None and options.noninj_user_tag is None:
            raise ValueError(
                "Need to set the noninj-user-tag since noninj-database is set")

        if options.inj_database is not None and options.inj_user_tag is None:
            raise ValueError(
                "Need to set the inj-user-tag since inj-database is set")

        if options.shift_database is not None and options.shift_user_tag is None:
            raise ValueError(
                "Need to set the shift-user-tag since shift-database is set")

    if not filenames:
        filenames = []

    return options, filenames


#
# =============================================================================
#
#								   Database
#
# =============================================================================
#


class SegmentsTable(object):
    def __init__(self, base):
        self.all_segs_dict = {}
        self.data = []
        self.table = []
        self.base = base

    def add_contents(self, contents):
        # only process non-injection documents
        if contents.sim_inspiral_table is None:
            for name, seglists in contents.all_segs_dict.items():
                # need to use operator because Python won't
                # allow a function call on the LHS of |=
                # for some mystery reason.
                operator.ior(
                    self.all_segs_dict.setdefault(name,
                                                  segments.segmentlistdict()),
                    seglists)

    def finish(self):
        segs = reduce(segments.segmentlistdict.__or__,
                      self.all_segs_dict.values(), segments.segmentlistdict())
        self.extent = segs.extent_all()

        for name, seglists in self.all_segs_dict.items():
            for ifo, seglist in seglists.items():
                for seg in seglist:
                    self.data.append([
                        "%s: %s" % (str(ifo), str(name)), "",
                        "%.2f-%.2f" % (float(seg[0]), float(seg[1])),
                        float(seg[0]) * 1000 + 315964800000 - 17000,
                        float(seg[1]) * 1000 + 315964800000 - 17000
                    ])

            analyzable_instruments_set = set(segs.keys())
            for n in range(1, 1 + len(segs)):
                for ifo_combos in itertools.combinations(
                        list(analyzable_instruments_set), n):
                    this = segs.intersection(ifo_combos) - segs.union(
                        analyzable_instruments_set - set(ifo_combos))
                    if len(this) > 0:
                        #FIXME inf is not handled properly
                        start = float(this.extent()[0])
                        end = float(this.extent()[1])
                        if end == float("inf"):
                            end = 2000000000.
                        duration = end - start
                        self.table.append(
                            [name, ",".join(ifo_combos), start, end, duration])

            self.table.insert(0, [
                "all", "all",
                float(self.extent[0]),
                float(self.extent[1]),
                float(abs(self.extent))
            ])
            f = open("%s_segments.json" % self.base, "w")
            f.write(repr(self.data))
            f.close()
            to_google_json("%s_segment_table.json" % self.base,
                           [("name", "string"), ("ifos", "string"),
                            ("start", "number"), ("end", "number"),
                            ("extent", "number")], self.table)
            yield None, None, None


class CoincDatabase(object):
    def __init__(self,
                 connection,
                 data_segments_name,
                 veto_segments_name=None,
                 verbose=False,
                 plotsummary_json=None,
                 wiki=None,
                 base=None,
                 program_name="gstlal_inspiral"):
        """
		Compute and record some summary information about the
		database.
		"""

        self.base = base
        self.connection = connection
        xmldoc = postcoh_table_def.get_xml(connection)
        self.all_segs_dict = {}

        cursor = connection.cursor()

        # find the tables
        try:
            self.sim_inspiral_table = lsctables.SimInspiralTable.get_table(
                xmldoc)
        except ValueError:
            self.sim_inspiral_table = None

        try:
            self.postcoh_inspiral_table = postcoh_table_def.PostcohInspiralTable.get_table(
                xmldoc)
        except ValueError:
            self.postcoh_inspiral_table = None

        # retrieve the distinct on and participating instruments
        self.on_instruments_combos = [
            frozenset(lsctables.instrument_set_from_ifos(x))
            for x, in cursor.execute("SELECT DISTINCT(ifos) FROM postcoh")
        ]
        self.participating_instruments_combos = [
            frozenset(lsctables.instrument_set_from_ifos(x))
            for x, in cursor.execute("SELECT DISTINCT(ifos) FROM postcoh")
        ]

        # get the segment lists
        self.seglists = ligolw_segments.segmenttable_get_by_name(
            xmldoc, data_segments_name).coalesce()
        self.instruments = set(self.seglists)
        if veto_segments_name is not None:
            self.veto_segments = ligolw_segments.segmenttable_get_by_name(
                xmldoc, veto_segments_name).coalesce()
        else:
            self.veto_segments = segments.segmentlistdict()
        self.seglists -= self.veto_segments

        # get all the segments in the database to use as a summary
        for llwsegs in ligolw_segments.LigolwSegments(xmldoc).coalesce():
            seglists = self.all_segs_dict.setdefault(
                llwsegs.name, segments.segmentlistdict())
            # FIXME:  should be populating valid segments upstream
            seglists |= segments.segmentlistdict.fromkeys(
                llwsegs.instruments, llwsegs.active)  #& llwsegs.valid)

        # get the live time
        if verbose:
            print >> sys.stderr, "calculating background livetimes: ",
        #self.offset_vectors = db_thinca_rings.get_background_offset_vectors(connection)

        if verbose:
            print >> sys.stderr
        self.zerolag_livetime = {}
        self.background_livetime = {}
        self.segs_livetime = 0
        for on_instruments in self.on_instruments_combos:
            self.zerolag_livetime[on_instruments] = float(
                abs(
                    self.seglists.intersection(on_instruments) -
                    self.seglists.union(self.instruments - on_instruments)))
            if len(on_instruments) >= 2:
                self.segs_livetime += self.zerolag_livetime[on_instruments]
        # FIXME:  background livetime hard-coded to be same
        # as zero-lag livetime.  figure out what to do
        self.background_livetime.update(self.zerolag_livetime)

        # verbosity
        if verbose:
            print >> sys.stderr, "database overview:"
            for on_instruments in self.on_instruments_combos:
                print >> sys.stderr, "\tzero-lag livetime for %s: %f s" % (
                    "+".join(sorted(on_instruments)),
                    self.zerolag_livetime[on_instruments])
                print >> sys.stderr, "\tbackground livetime for %s: %f s" % (
                    "+".join(sorted(on_instruments)),
                    self.background_livetime[on_instruments])
            if self.sim_inspiral_table is not None:
                print >> sys.stderr, "\tinjections: %d" % len(
                    self.sim_inspiral_table)

        if wiki:
            wiki.write("database overview:\n\n")
            for on_instruments in self.on_instruments_combos:
                wiki.write("||zero-lag livetime for %s||%f s||\n" %
                           ("+".join(sorted(on_instruments)),
                            self.zerolag_livetime[on_instruments]))
                wiki.write("||background livetime for %s ||%f s||\n" %
                           ("+".join(sorted(on_instruments)),
                            self.background_livetime[on_instruments]))
            if self.sim_inspiral_table is not None:
                wiki.write("||injections|| %d||\n" %
                           len(self.sim_inspiral_table))

        if plotsummary_json:
            data = []
            for on_instruments in self.on_instruments_combos:
                data.append([
                    "zero-lag livetime for %s" %
                    ("+".join(sorted(on_instruments))),
                    str(self.zerolag_livetime[on_instruments])
                ])
                data.append([
                    "background livetime for %s" %
                    ("+".join(sorted(on_instruments))),
                    str(self.background_livetime[on_instruments])
                ])
            if self.postcoh_inspiral_table is not None:
                data.append(
                    ["inspiral events",
                     str(len(self.postcoh_inspiral_table))])
            if self.sim_inspiral_table is not None:
                data.append(["injections", str(len(self.sim_inspiral_table))])
            # only output this summary for noninj or shift
            if self.sim_inspiral_table is None:
                to_google_json("%s_%s" % (self.base, "plotsummary.json"),
                               [('Summary of database:', 'string'),
                                (plotsummary_json, 'string')], data)


#
# =============================================================================
#
#								  Utilities
#
# =============================================================================
#


def roman(i,
          arabics=(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1),
          romans=("m", "cm", "d", "cd", "c", "xc", "l", "xl", "x", "ix", "v",
                  "iv", "i")):
    if not arabics:
        return ""
    if i < arabics[0]:
        return roman(i, arabics[1:], romans[1:])
    return romans[0] + roman(i - arabics[0], arabics, romans)


#
# width is in mm, default aspect ratio is the golden ratio
#


def create_plot(x_label=None, y_label=None, width=165.0, aspect=None):
    if aspect is None:
        aspect = (1 + math.sqrt(5)) / 2
    fig = figure.Figure()
    FigureCanvas(fig)
    fig.set_size_inches(width / 25.4, width / 25.4 / aspect)
    axes = fig.gca()
    axes.grid(True)
    if x_label is not None:
        axes.set_xlabel(x_label)
    if y_label is not None:
        axes.set_ylabel(y_label)
    return fig, axes


def create_sim_coinc_view(connection):
    """
	Construct a sim_inspiral --> best matching coinc_event mapping.
	Only injections that match at least one coinc get an entry in this
	table. if there are more than entries, select the smallest far one
		the format is like:
			simulation_id, event_id, far
			sim_inspiral:simulation_id:32135,postcoh:event_id:241023,1.3e-7
			sim_inspiral:simulation_id:32155,postcoh:event_id:250000,4.5e-3
		note the simulation_id and event_id may not be continous
		"""
    #
    # the log likelihood ratio stored in the likelihood column of the
    # coinc_event table is the ranking statistic.  the "best match" is
    # the coinc with the highest value in this column.  although it has
    # not been true in the past, there is now a one-to-one relationship
    # between the value of this ranking statistic and false-alarm rate,
    # therefore it is OK to order by log likelihood ratio and then,
    # later, impose a "detection" threshold based on false-alarm rate.
    #

    connection.cursor().execute("""
CREATE TEMPORARY TABLE
	sim_coinc_map
AS
	SELECT
		sim_inspiral.simulation_id AS simulation_id,
		(
			SELECT
				a.coinc_event_id
			FROM
				coinc_event_map AS a
				JOIN postcoh ON (
					postcoh.event_id == a.coinc_event_id
				)
			WHERE
				a.table_name == 'sim_inspiral'
				AND a.event_id == sim_inspiral.simulation_id
			ORDER BY
				postcoh.far ASC
			LIMIT 1
		) as coinc_event_id,
		(
			SELECT
				postcoh.far
			FROM
				coinc_event_map AS a
				JOIN postcoh ON (
					postcoh.event_id == a.coinc_event_id
				)
			WHERE
				a.table_name == 'sim_inspiral'
				AND a.event_id == sim_inspiral.simulation_id
			ORDER BY
				postcoh.far ASC
			LIMIT 1
		) as far
		FROM
		sim_inspiral
	WHERE
		coinc_event_id IS NOT NULL
	""")


#
# =============================================================================
#
#					  Summary Table
#
# =============================================================================
#
"""
split the Summary Table for 2 purposes:
	1. display 10 most significant events for noninj database
	2. display 10 most significant events for shift database
"""


class SummaryTable(object):
    def __init__(self, tag):
        self.candidates = []
        self.bgcandidates = []
        self.livetime = {}
        self.num_trigs = {}
        self.tag = tag

    def add_contents(self, contents):
        self.base = contents.base
        if contents.sim_inspiral_table:
            #For now we only return summary information on non injections
            return
        # FIXME: third should be ranking_statistic
        select_candidates = contents.connection.cursor().execute("""
SELECT
	postcoh.far,
	postcoh.fap,
	postcoh.fap, 
	postcoh.cohsnr,
	postcoh.end_time + postcoh.end_time_ns * 1e-9,
	postcoh.mtotal,
	postcoh.mchirp,
	postcoh.ifos,
	postcoh.mass1,
	postcoh.mass2,
	postcoh.spin1z,
	postcoh.spin2z,
	postcoh.snglsnr_H1,
	postcoh.chisq_H1,
	postcoh.snglsnr_L1,
	postcoh.chisq_L1,
	postcoh.snglsnr_V1,
	postcoh.chisq_V1
FROM
	postcoh
WHERE postcoh.far > 0.0
ORDER BY
	far
LIMIT 100
		""").fetchall()

        if self.tag == "noninj":
            self.candidates = select_candidates
        elif self.tag == "shift":
            self.bgcandidates = select_candidates
        else:
            raise ValueError

    def write_candidate_json(self, candidates, fname):
        data = []
        # FIXME generalize for virgo
        description = [
            ("Rank", "number"),
            ("FAR (Hz)", "string"),
            ("FAP", "string"),
            ("ranking_statistic", "string"),
            ("&rho;", "number"),
            ("<i>t</i>", "number"),
            ("<i>M</i><sub>total</sub> / M<sub>&#x2299;</sub>", "number"),
            ("<i>M</i><sub>chirp</sub> / M<sub>&#x2299;</sub>", "number"),
            ("Participating<br>Instruments", "string"),
            ("m<sub>1</sub>", "number"),
            ("m<sub>2</sub>", "number"),
            ("s<sub>1z</sub>", "number"),
            ("s<sub>2z</sub>", "number"),
            ("H1 &rho;", "string"),
            ("H1 &chi;<sup>2</sup>", "string"),
            ("L1 &rho;", "string"),
            ("L1 &chi;<sup>2</sup>", "string"),
            ("V1 &rho;", "string"),
            ("V1 &chi;<sup>2</sup>", "string"),
        ]
        for rank, values in enumerate(candidates, 1):
            row = [rank] + [float(v) for v in values[:7]
                            ] + [values[7]] + [float(v) for v in values[8:12]]
            # values[9] is a string that is e.g., H1:4.8993754:1.0139208:2.061641:1.145543 L1:8.2582664:1.1890973:2.061641:1.145543
            ifodict = {
                "H1": [float(values[12]), float(values[13])],
                "L1": [float(values[14]), float(values[15])],
                "V1": [float(values[16]), float(values[17])]
            }
            row.extend(ifodict["H1"])
            row.extend(ifodict["L1"])
            row.extend(ifodict["V1"])
            data.append(row)
        to_google_json(fname, description, data)

    def finish(self):
        if self.tag == "noninj":
            self.candidates.sort()
            self.write_candidate_json(self.candidates[:101],
                                      self.base + '_summary_table.json')
            yield None, None, None
        elif self.tag == "shift":
            self.bgcandidates.sort()
            self.write_candidate_json(self.bgcandidates[:101],
                                      self.base + '_bgsummary_table.json')
            yield None, None, None


#
# =============================================================================
#
#					  Injection Parameter Distributions
#
# =============================================================================
#


class InjectionParameterDistributionPlots(object):
    def __init__(self):
        self.injections = {}

    def add_contents(self, contents):
        if contents.sim_inspiral_table is None:
            # no injections
            return
        for values in contents.connection.cursor().execute("""
SELECT
	*
FROM
	sim_inspiral
			"""):
            sim = contents.sim_inspiral_table.row_from_cols(values)
            del sim.process_id, sim.source, sim.simulation_id
            instruments = frozenset(
                instrument
                for instrument, segments in contents.seglists.items()
                if sim.get_time_geocent() in segments)
            self.injections.setdefault(sim.waveform, []).append(sim)

    def finish(self):
        for waveform, sims in self.injections.items():
            for col1, col2, ax1, ax2, name, aspect in [
                ([sim.mass1 for sim in sims], [sim.mass2 for sim in sims],
                 r"$M_{1}$ ($\mathrm{M}_{\odot}$)",
                 r"$M_{2}$ ($\mathrm{M}_{\odot}$)", "sim_dist_m1_m2_%s", 1),
                ([sim.geocent_end_time for sim in sims
                  ], [math.log10(sim.distance) for sim in sims], r"Time (s)",
                 r"$\log_{10} (\mathrm{distance} / 1\,\mathrm{Mpc})$",
                 "sim_dist_time_distance_%s", None),
                ([sim.longitude * 12 / math.pi for sim in sims
                  ], [math.sin(sim.latitude) for sim in sims], r"RA (h)",
                 r"$\sin \mathrm{dec}$", "sim_dist_ra_dec_%s", None),
                ([math.cos(sim.inclination)
                  for sim in sims], [sim.polarization for sim in sims
                                     ], r"$\cos $Inclination (rad)",
                 r"Polarization (rad)", "sim_dist_inc_pol_%s", None),
                ([sim.spin1z for sim in sims], [sim.spin2z for sim in sims],
                 r"Spin 1 z", r"Spin 2 z", "sim_dist_spin1z_spin2z_%s", None)
            ]:
                fig, axes = create_plot(ax1, ax2, aspect=aspect)
                axes.set_title(
                    r"Injection Parameter Distribution (%s Injections)" %
                    waveform)
                if len(col1) > 16383:
                    axes.plot(col1, col2, "k,")
                else:
                    axes.plot(col1, col2, "k.")
                minx, maxx = axes.get_xlim()
                miny, maxy = axes.get_ylim()
                if aspect == 1:
                    axes.set_xlim((min(minx, miny), max(maxx, maxy)))
                    axes.set_ylim((min(minx, miny), max(maxx, maxy)))
                yield fig, name % (waveform), False


#
# =============================================================================
#
#							  ROC plots
#
# =============================================================================
#


class ROCPlots(object):
    class ROC(object):
        def __init__(self, on_instruments):
            self.on_instruments = on_instruments
            self.ln_far_thresh = numpy.linspace(-9., -3., 100)
            trigger_thresh = numpy.log10(1 / 30. / 86400)
            self.trigger_idx = min(
                numpy.where(self.ln_far_thresh > trigger_thresh)[0])
            self.nfound = numpy.zeros(len(self.ln_far_thresh))
            self.nfa = numpy.zeros(len(self.ln_far_thresh))
            self.myfound = []
            self.myfa = []

        def add_contents(self, contents):
            zerolag_segments = contents.seglists.intersection(
                self.on_instruments) - contents.seglists.union(
                    contents.instruments - self.on_instruments)
            init_far_thresh = numpy.power(10, max(self.ln_far_thresh))
            for values in contents.connection.cursor().execute(
                    """
SELECT
	sim_inspiral.*,
	(
		SELECT
			postcoh.far
		FROM
			sim_coinc_map
			JOIN postcoh ON (
				postcoh.event_id == sim_coinc_map.coinc_event_id
			)
		WHERE
			sim_coinc_map.simulation_id == sim_inspiral.simulation_id
			AND postcoh.far < ? AND postcoh.far > 0.0
	)
FROM
	sim_inspiral
		""", (init_far_thresh, )):
                sim = contents.sim_inspiral_table.row_from_cols(values)
                if sim.get_time_geocent(
                ) in zerolag_segments and values[-1] is not None:
                    self.myfound.append((sim.simulation_id, values[-1]))

            for values in contents.connection.cursor().execute(
                    """
SELECT
	postcoh.event_id, postcoh.far
FROM
	postcoh
	LEFT JOIN coinc_event_map ON (
		postcoh.event_id == coinc_event_map.coinc_event_id
	)
WHERE
	postcoh.far < ? AND postcoh.far > 0.0
	AND coinc_event_map.coinc_event_id IS NULL
		""", (init_far_thresh, )):
                self.myfa.append((values[0], values[-1]))

            for i, ln_far_thresh in enumerate(self.ln_far_thresh):
                this_far_thresh = numpy.power(10, ln_far_thresh)
                this_found = [
                    one_found for one_found in self.myfound
                    if one_found[-1] < this_far_thresh
                ]
                self.nfound[i] = len(this_found)
                this_fa = [
                    one_fa for one_fa in self.myfa
                    if one_fa[-1] < this_far_thresh
                ]
                self.nfa[i] = len(this_fa)

        def finish(self):
            fig, axes = create_plot(r"Found (n)", r"False alarms (n)")
            axes.set_title(r"Found vs.\ False Alarms (With %s Operating)" %
                           ", ".join(sorted(self.on_instruments)))
            axes.plot(self.nfound, self.nfa, "kx")
            axes.plot(self.nfound[self.trigger_idx],
                      self.nfa[self.trigger_idx], "ro")
            yield fig, "found_vs_fa", False

    def __init__(self):
        self.plots = {}
        self.base = ''

    def add_contents(self, contents):
        self.base = contents.base
        if contents.sim_inspiral_table is None:
            # no injections
            return
        for on_instruments in contents.on_instruments_combos:
            if on_instruments not in self.plots:
                self.plots[on_instruments] = ROCPlots.ROC(on_instruments)
            self.plots[on_instruments].add_contents(contents)

    def finish(self):
        for on_instruments, plot in self.plots.items():
            for fig, filename_fragment, is_open_box in plot.finish():
                yield fig, "%s_%s" % (filename_fragment, "".join(
                    sorted(on_instruments))), is_open_box


#
# =============================================================================
#
#							  Missed/Found Plot
#
# =============================================================================
#


class MissedFoundPlots(object):
    class MissedFound(object):
        def __init__(self, on_instruments, far_thresh, missed_found_plots):
            self.on_instruments = on_instruments
            self.far_thresh = far_thresh
            self.found_in = {}
            self.missed_found_plots = missed_found_plots

        def add_contents(self, contents):
            self.base = contents.base
            zerolag_segments = contents.seglists.intersection(
                self.on_instruments) - contents.seglists.union(
                    contents.instruments - self.on_instruments)
            for values in contents.connection.cursor().execute(
                    """
SELECT
	sim_inspiral.*,
	(
		SELECT
			postcoh.ifos
		FROM
			sim_coinc_map
			JOIN postcoh ON (
				postcoh.event_id == sim_coinc_map.coinc_event_id
			)
		WHERE
			sim_coinc_map.simulation_id == sim_inspiral.simulation_id
			AND postcoh.far < ? AND postcoh.far > 0.0
	)
FROM
	sim_inspiral
			""", (self.far_thresh if self.far_thresh is not None else float("+inf"), )):
                sim = contents.sim_inspiral_table.row_from_cols(values)
                del sim.process_id, sim.source, sim.simulation_id

                if sim.get_time_geocent() in zerolag_segments:
                    participating_instruments = lsctables.instrument_set_from_ifos(
                        values[-1])
                    if participating_instruments is not None:
                        participating_instruments = frozenset(
                            participating_instruments)
                    try:
                        self.found_in[participating_instruments].append(sim)
                    except KeyError:
                        self.found_in[participating_instruments] = [sim]

        def finish(self):

            f = open(self.base + "_injection_summary.txt", "a")
            missed = self.found_in.pop(None, [])

            # Define decisive distance even if there is one instrument
            def decisive_distance(sim, instruments):
                if len(instruments) > 1:
                    return sorted(
                        sim.get_eff_dist(instrument)
                        for instrument in instruments)[1]
                else:
                    return sim.get_eff_dist(list(instruments)[0])

            def decisive_chirp_distance(sim, instruments):
                if len(instruments) > 1:
                    return sorted(
                        sim.get_chirp_eff_dist(instrument)
                        for instrument in instruments)[1]
                else:
                    return sim.get_chirp_eff_dist(list(instruments)[0])

            def found_decisive_charsnr(sim, oninstruments, partinstruments):
                if len(oninstruments) == 1:
                    ifo, = oninstruments
                    if ifo == 'H1':
                        return sim.alpha4
                    if ifo == 'L1':
                        return sim.alpha5
                    if ifo == 'V1':
                        return sim.alpha6
                if len(oninstruments) > 3:
                    raise ValueError(
                        "More than 3 instruments not supported for injection snr calculation at this time."
                    )
                else:
                    if len(partinstruments) == 1:
                        ifo, = partinstruments
                        if ifo == 'H1':
                            return sim.alpha4
                        if ifo == 'L1':
                            return sim.alpha5
                        if ifo == 'V1':
                            return sim.alpha6
                    else:
                        return sorted([sim.alpha4, sim.alpha5, sim.alpha6])[1]

            def missed_decisive_charsnr(sim, oninstruments):
                if len(oninstruments) == 1:
                    ifo, = oninstruments
                    if ifo == 'H1':
                        return sim.alpha4
                    if ifo == 'L1':
                        return sim.alpha5
                    if ifo == 'V1':
                        return sim.alpha6
                if len(oninstruments) > 3:
                    raise ValueError(
                        "More than 3 instruments not supported for injection snr calculation at this time."
                    )
                else:
                    return sorted([sim.alpha4, sim.alpha5, sim.alpha6])[1]

            for cnt, (
                    title, x_label, x_func, y_label, y_func, filename_fragment
            ) in enumerate((
                (r"$\textrm{Distance vs.\ Chirp Mass (With %s Operating)}$" %
                 ", ".join(sorted(self.on_instruments)),
                 r"$M_{\mathrm{chirp}}$ ($\mathrm{M}_{\odot}$)",
                 lambda sim: sim.mchirp, r"$D$ ($\mathrm{Mpc}$)",
                 lambda sim, instruments: sim.distance, "d_vs_mchirp"),
                (r"$\textrm{Decisive Distance vs.\ Chirp Mass (With %s Operating)}$"
                 % ", ".join(sorted(self.on_instruments)),
                 r"$M_{\mathrm{chirp}}$ ($\mathrm{M}_{\odot}$)",
                 lambda sim: sim.mchirp,
                 r"$\mathrm{Decisive} D_{\mathrm{eff}}$ ($\mathrm{Mpc}$)",
                 decisive_distance, "deff_vs_mchirp"),
                (r"$\textrm{Chirp Decisive Distance vs.\ Chirp Mass (With %s Operating)}$"
                 % ", ".join(sorted(self.on_instruments)),
                 r"$M_{\mathrm{chirp}}$ ($\mathrm{M}_{\odot}$)",
                 lambda sim: sim.mchirp,
                 r"$\mathrm{Decisive} D_{\mathrm{chirp, eff}}$ ($\mathrm{Mpc}$)",
                 decisive_chirp_distance, "chirpdist_vs_mchirp"),
                (r"$\textrm{Chirp Decisive Distance vs.\ Eta (With %s Operating)}$"
                 % ", ".join(sorted(self.on_instruments)), r"$\eta$",
                 lambda sim: sim.eta,
                 r"$\mathrm{Decisive} D_{\mathrm{chirp, eff}}$ ($\mathrm{Mpc}$)",
                 decisive_chirp_distance, "chirpdist_vs_eta"),
                (r"$\textrm{Decisive Distance vs.\ Total Mass (With %s Operating)}$"
                 % ", ".join(sorted(self.on_instruments)),
                 r"$M_{\mathrm{total}}$ ($\mathrm{M}_{\odot}$)",
                 lambda sim: sim.mass1 + sim.mass2,
                 r"$\mathrm{Decisive} D_{\mathrm{eff}}$ ($\mathrm{Mpc}$)",
                 decisive_distance, "deff_vs_mtotal"),
                (r"$\textrm{Decisive Distance vs.\ Effective Spin (With %s Operating)}$"
                 % ", ".join(sorted(self.on_instruments)), r"$\chi$",
                 lambda sim:
                 (sim.spin1z * sim.mass1 + sim.spin2z * sim.mass2) /
                 (sim.mass1 + sim.mass2),
                 r"$\mathrm{Decisive} D_{\mathrm{eff}}$ ($\mathrm{Mpc}$)",
                 decisive_distance, "deff_vs_chi"),
                (r"$\textrm{Decisive Distance vs.\ Time (With %s Operating)}$"
                 % ", ".join(sorted(self.on_instruments)), r"GPS Time (s)",
                 lambda sim: sim.get_time_geocent(),
                 r"$\mathrm{Decisive} D_{\mathrm{eff}}$ ($\mathrm{Mpc}$)",
                 decisive_distance, "deff_vs_t"))):

                fig, axes = create_plot(x_label, y_label)
                legend = []
                for participating_instruments, sims in sorted(
                        self.found_in.items(),
                        key=(lambda x: lsctables.instrumentsproperty(x[0]))):
                    if cnt == 0:
                        self.missed_found_plots.injection_summary_data.append([
                            "Found", "".join(sorted(self.on_instruments)),
                            "".join(sorted(participating_instruments)),
                            len(sims)
                        ])
                        f.write("Found in %s: %d" % (", ".join(
                            sorted(participating_instruments)), len(sims)))
                    legend.append("Found in %s" %
                                  ", ".join(sorted(participating_instruments)))
                    axes.semilogy([x_func(sim) for sim in sims], [
                        y_func(sim, participating_instruments) for sim in sims
                    ], ".")
                if missed:
                    if cnt == 0:
                        self.missed_found_plots.injection_summary_data.append([
                            "Missed", "".join(sorted(self.on_instruments)),
                            "---",
                            len(missed)
                        ])
                        f.write("Missed in %s: %d" % (", ".join(
                            sorted(self.on_instruments)), len(missed)))
                        for rank, sim in enumerate(missed):
                            self.missed_found_plots.missed_summary_data.append(
                                [
                                    "".join(sorted(self.on_instruments)),
                                    sim.waveform,
                                    float(
                                        sim.time_at_instrument(
                                            "H1", {"H1": 0.0})),
                                    float(
                                        sim.time_at_instrument(
                                            "L1", {"L1": 0.0})), sim.mass1,
                                    sim.mass2, sim.spin1x, sim.spin1y,
                                    sim.spin1z, sim.spin2x, sim.spin2y,
                                    sim.spin2z, sim.distance,
                                    decisive_chirp_distance(
                                        sim, self.on_instruments),
                                    sim.inclination, sim.alpha4, sim.alpha5,
                                    missed_decisive_charsnr(
                                        sim, self.on_instruments)
                                ])
                    legend.append("Missed")
                    axes.semilogy(
                        [x_func(sim) for sim in missed],
                        [y_func(sim, self.on_instruments)
                         for sim in missed], "k.")
                if legend:
                    axes.legend(legend)
                axes.set_title(title)
                yield fig, filename_fragment, False

            f.close()
            for cnt, (
                    title, x_label, x_func, y_label, filename_fragment
            ) in enumerate((
                (r"Decisive Characteristic SNR vs.\ Chirp Mass (With %s Operating)"
                 % ", ".join(sorted(self.on_instruments)),
                 r"$M_{\mathrm{chirp}}$ ($\mathrm{M}_{\odot}$)",
                 lambda sim: sim.mchirp, r"Decisive Characteristic SNR",
                 "dec_expsnr_vs_mchirp"),
                (r"Decisive Characteristic SNR vs.\ Total Mass (With %s Operating)"
                 % ", ".join(sorted(self.on_instruments)),
                 r"$M_{\mathrm{total}}$ ($\mathrm{M}_{\odot}$)",
                 lambda sim: sim.mass1 + sim.mass2,
                 r"Decisive Characteristic SNR", "dec_expsnr_vs_mtotal"),
                (r"Decisive Characteristic SNR vs.\ Eta (With %s Operating)" %
                 ", ".join(sorted(self.on_instruments)), r"$\eta$",
                 lambda sim: sim.eta, r"Decisive Characteristic SNR",
                 "dec_expsnr_vs_eta"),
                (r"Decisive Characteristic SNR vs.\ Effective Spin (With %s Operating)"
                 % ", ".join(sorted(self.on_instruments)), r"$\chi$",
                 lambda sim:
                 (sim.spin1z * sim.mass1 + sim.spin2z * sim.mass2) /
                 (sim.mass1 + sim.mass2), r"Decisive Characteristic SNR",
                 "dec_expsnr_vs_chi"),
                (r"Decisive Characteristic SNR vs.\ Time (With %s Operating)" %
                 ", ".join(sorted(self.on_instruments)), r"GPS Time (s)",
                 lambda sim: sim.get_time_geocent(),
                 r"Decisivive Characteristic SNR", "dec_expsnr_vs_t"))):
                fig, axes = create_plot(x_label, y_label)
                legend = []
                try:
                    for participating_instruments, sims in sorted(
                            self.found_in.items(),
                            key=(lambda x: lsctables.instrumentsproperty.set(x[
                                0]))):
                        legend.append(
                            "Found in %s" %
                            ", ".join(sorted(participating_instruments)))
                        axes.semilogy([x_func(sim) for sim in sims], [
                            found_decisive_charsnr(sim, self.on_instruments,
                                                   participating_instruments)
                            for sim in sims
                        ], ".")
                    if missed:
                        legend.append("Missed")
                        axes.semilogy([x_func(sim) for sim in missed], [
                            missed_decisive_charsnr(sim, self.on_instruments)
                            for sim in missed
                        ], "k.")
                    if legend:
                        axes.legend(legend)
                    axes.set_title(title)
                    yield fig, filename_fragment, False
                except ValueError:
                    print >> sys.stderr, "Cannot create expected SNR plots, no positive values, probably the SNRs are not set"

    def __init__(self, far_thresh):
        self.far_thresh = far_thresh
        self.plots = {}
        self.injection_summary_data = []
        self.missed_summary_data = []

    def add_contents(self, contents):
        self.base = contents.base
        if contents.sim_inspiral_table is None:
            # no injections
            return
        for on_instruments in contents.on_instruments_combos:
            if on_instruments not in self.plots:
                self.plots[on_instruments] = MissedFoundPlots.MissedFound(
                    on_instruments, self.far_thresh, self)
            self.plots[on_instruments].add_contents(contents)

    def finish(self):
        f = open(self.base + "_injection_summary.txt", "w")
        f.write(
            "||<b>ON INSTRUMENTS</b>||<b> PARTICIPATING INSTRUMENTS</b>||<b>MISSED/FOUND</b||\n"
        )
        f.close()
        for on_instruments, plot in self.plots.items():
            for fig, filename_fragment, is_open_box in plot.finish():
                yield fig, "%s_%s" % (filename_fragment, "".join(
                    sorted(on_instruments))), is_open_box

        to_google_json(self.base + "_injection_summary.json",
                       [("Found||Missed", "string"),
                        ("On Instruments", "string"),
                        ("Participating Instruments", "string"),
                        ("count", "number")], self.injection_summary_data)
        to_google_json(self.base + "_missed_summary.json",
                       [("On Instruments", "string"), ("Waveform", "string"),
                        ("H1 <i>t</i>", "number"), ("L1 <i>t</i>", "number"),
                        ("<i>m</i><sub>1</sub>", "number"),
                        ("<i>m</i><sub>2</sub>", "number"),
                        ("<i>s</i><sub>1x</sub>", "number"),
                        ("<i>s</i><sub>1y</sub>", "number"),
                        ("<i>s</i><sub>1z</sub>", "number"),
                        ("<i>s</i><sub>2x</sub>", "number"),
                        ("<i>s</i><sub>2y</sub>", "number"),
                        ("<i>s</i><sub>2z</sub>", "number"),
                        ("D (Mpc)", "number"),
                        ("Decisive D<sub>chirp,eff</sub> (Mpc)", "number"),
                        ("Inclination", "number"), ("H1 &rho;", "number"),
                        ("L1 &rho;", "number"), ("Decisive &rho;", "number")],
                       self.missed_summary_data)


#

#
# =============================================================================
#
#							  Parameter Accuracy
#
# =============================================================================
#


class ParameterAccuracyPlots(object):
    def __init__(self, far_thresh=1e-4):
        self.sim_postcoh_pairs = {}
        self.far_thresh = far_thresh

    def add_contents(self, contents):
        if contents.sim_inspiral_table is None:
            # not an injections file
            return
        n_simcolumns = len(contents.sim_inspiral_table.columnnames)
        for values in contents.connection.cursor().execute("""
SELECT
	sim_inspiral.*,
	postcoh.*,postcoh.far
FROM
	sim_inspiral
	JOIN sim_coinc_map ON (
		sim_coinc_map.simulation_id == sim_inspiral.simulation_id
	)
	JOIN postcoh ON (
		postcoh.event_id == sim_coinc_map.coinc_event_id
	)
	WHERE postcoh.cohsnr > 4.0
		"""):
            sim = contents.sim_inspiral_table.row_from_cols(values)
            postcoh = contents.postcoh_inspiral_table.row_from_cols(
                values[n_simcolumns:-1])
            far = values[-1]
            del sim.process_id, sim.source, sim.simulation_id
            del postcoh.event_id
            if far <= self.far_thresh and far > 0.0:
                self.sim_postcoh_pairs.setdefault((sim.waveform, postcoh.ifos),
                                                  []).append(
                                                      (sim, postcoh, far))

    def finish(self):
        def hist(arr, axes):
            start = scipy_stats.mstats.mquantiles(arr, 0.01)
            end = scipy_stats.mstats.mquantiles(arr, 0.99)
            axes.hist(arr, numpy.linspace(start, end, 100))

        for (waveform, ifos), pairs in self.sim_postcoh_pairs.items():
            on_instruments = set(re.findall(r'[A-Z][0-9]', ifos))
            for instrument in on_instruments:
                fig, axes = create_plot(
                    r"Inj. $M_{\mathrm{chirp}}$ ($\mathrm{M}_{\odot}$)",
                    r"Rec. $M_{\mathrm{chirp}}$ - Inj. $M_{\mathrm{chirp}}$ ($\mathrm{M}_{\odot}$)"
                )
                axes.set_title(
                    r"Absolute $M_{\mathrm{chirp}}$ Accuracy in %s (%s Injections)"
                    % (instrument, waveform))
                cb = axes.scatter([sim.mchirp for sim, postcoh, far in pairs],
                                  [
                                      postcoh.mchirp - sim.mchirp
                                      for sim, postcoh, far in pairs
                                  ],
                                  c=[far for sim, postcoh, far in pairs],
                                  norm=matplotlib.colors.LogNorm(),
                                  vmin=1e-13,
                                  vmax=1e-3,
                                  linewidth=0.2,
                                  alpha=0.8)
                fig.colorbar(cb, ax=axes).set_label("FAR (Hz)")
                yield fig, "mchirp_acc_abs_scatter_%s_%s" % (waveform,
                                                             instrument), False

                fig, axes = create_plot(
                    r"Rec. $M_{\mathrm{chirp}}$ - Inj. $M_{\mathrm{chirp}}$ ($\mathrm{M}_{\odot}$)",
                    "Number")
                axes.set_title(
                    r"Absolute $M_{\mathrm{chirp}}$ Accuracy in %s (%s Injections)"
                    % (instrument, waveform))
                hist(
                    numpy.array([
                        postcoh.mchirp - sim.mchirp
                        for sim, postcoh, far in pairs
                    ]), axes)
                yield fig, "mchirp_acc_abs_hist_%s_%s" % (waveform,
                                                          instrument), False

                fig, axes = create_plot(
                    r"Inj. $M_{\mathrm{chirp}}$ ($\mathrm{M}_{\odot}$)",
                    r"(Rec. $M_{\mathrm{chirp}}$ - Inj. $M_{\mathrm{chirp}}$) / Inj. $M_{\mathrm{chirp}}$"
                )
                axes.set_title(
                    r"Fractional $M_{\mathrm{chirp}}$ Accuracy in %s (%s Injections)"
                    % (instrument, waveform))
                cb = axes.scatter([sim.mchirp for sim, postcoh, far in pairs],
                                  [(postcoh.mchirp - sim.mchirp) / sim.mchirp
                                   for sim, postcoh, far in pairs],
                                  c=[far for sim, postcoh, far in pairs],
                                  norm=matplotlib.colors.LogNorm(),
                                  vmin=1e-13,
                                  vmax=1e-3,
                                  linewidth=0.2,
                                  alpha=0.8)
                fig.colorbar(cb, ax=axes).set_label("FAR (Hz)")
                yield fig, "mchirp_acc_frac_scatter_%s_%s" % (
                    waveform, instrument), False

                fig, axes = create_plot(
                    r"(Rec. $M_{\mathrm{chirp}}$ - Inj. $M_{\mathrm{chirp}}$)/ Inj. $M_{\mathrm{chirp}}$",
                    "Number")
                axes.set_title(
                    r"Fractional $M_{\mathrm{chirp}}$ Accuracy in %s (%s Injections)"
                    % (instrument, waveform))
                hist(
                    numpy.array([(postcoh.mchirp - sim.mchirp) / sim.mchirp
                                 for sim, postcoh, far in pairs]), axes)
                yield fig, "mchirp_acc_frac_hist_%s_%s" % (waveform,
                                                           instrument), False

                fig, axes = create_plot(
                    r"Inj. $M_{\mathrm{total}}$ ($\mathrm{M}_{\odot}$)",
                    r"(Rec. $M_{\mathrm{total}}$ - Inj. $M_{\mathrm{total}}$) / Inj. $M_{\mathrm{total}}$"
                )
                axes.set_title(
                    r"Fractional $M_{\mathrm{total}}$ Accuracy in %s (%s Injections)"
                    % (instrument, waveform))
                cb = axes.scatter([sim.mtotal for sim, postcoh, far in pairs],
                                  [(postcoh.mtotal - sim.mtotal) / sim.mtotal
                                   for sim, postcoh, far in pairs],
                                  c=[far for sim, postcoh, far in pairs],
                                  norm=matplotlib.colors.LogNorm(),
                                  vmin=1e-13,
                                  vmax=1e-3,
                                  linewidth=0.2,
                                  alpha=0.8)
                fig.colorbar(cb, ax=axes).set_label("FAR (Hz)")
                yield fig, "mtotal_acc_frac_scatter_%s_%s" % (
                    waveform, instrument), False

                fig, axes = create_plot(
                    r"(Rec. $M_{\mathrm{total}}$ - Inj. $M_{\mathrm{total}}$) / Inj. $M_{\mathrm{total}}$",
                    "Number")
                axes.set_title(
                    r"Fractional $M_{\mathrm{total}}$ Accuracy in %s (%s Injections)"
                    % (instrument, waveform))
                hist(
                    numpy.array([(postcoh.mtotal - sim.mtotal) / sim.mtotal
                                 for sim, postcoh, far in pairs]), axes)
                yield fig, "mtotal_acc_frac_hist_%s_%s" % (waveform,
                                                           instrument), False

                fig, axes = create_plot(r"Inj. $\eta$",
                                        r"Rec. $\eta$ - Inj. $\eta$")
                axes.set_title(
                    r"Absolute $\eta$ Accuracy in %s (%s Injections)" %
                    (instrument, waveform))
                cb = axes.scatter(
                    [sim.eta for sim, postcoh, far in pairs],
                    [postcoh.eta - sim.eta for sim, postcoh, far in pairs],
                    c=[far for sim, postcoh, far in pairs],
                    norm=matplotlib.colors.LogNorm(),
                    vmin=1e-13,
                    vmax=1e-3,
                    linewidth=0.2,
                    alpha=0.8)
                fig.colorbar(cb, ax=axes).set_label("FAR (Hz)")
                yield fig, "eta_acc_abs_scatter_%s_%s" % (waveform,
                                                          instrument), False

                fig, axes = create_plot(r"Rec. $\eta$ - Inj. $\eta$", "Number")
                axes.set_title(
                    r"Absolute $\eta$ Accuracy in %s (%s Injections)" %
                    (instrument, waveform))
                hist(
                    numpy.array([
                        postcoh.eta - sim.eta for sim, postcoh, far in pairs
                    ]), axes)
                yield fig, "eta_acc_abs_hist_%s_%s" % (waveform,
                                                       instrument), False

                fig, axes = create_plot(
                    r"Inj. $\eta$",
                    r"(Rec. $\eta$ - Inj. $\eta$) / Inj. $\eta$")
                axes.set_title(
                    r"Fractional $\eta$ Accuracy in %s (%s Injections)" %
                    (instrument, waveform))
                cb = axes.scatter([sim.eta for sim, postcoh, far in pairs],
                                  [(postcoh.eta - sim.eta) / sim.eta
                                   for sim, postcoh, far in pairs],
                                  c=[far for sim, postcoh, far in pairs],
                                  norm=matplotlib.colors.LogNorm(),
                                  vmin=1e-13,
                                  vmax=1e-3,
                                  linewidth=0.2,
                                  alpha=0.8)
                fig.colorbar(cb, ax=axes).set_label("FAR (Hz)")
                yield fig, "eta_acc_frac_scatter_%s_%s" % (waveform,
                                                           instrument), False

                fig, axes = create_plot(
                    r"(Rec. $\eta$ - Inj. $\eta$) / Inj. $\eta$", "Number")
                axes.set_title(
                    r"Fractional $\eta$ Accuracy in %s (%s Injections)" %
                    (instrument, waveform))
                hist(
                    numpy.array([(postcoh.eta - sim.eta) / sim.eta
                                 for sim, postcoh, far in pairs]), axes)
                yield fig, "eta_acc_frac_hist_%s_%s" % (waveform,
                                                        instrument), False

                fig, axes = create_plot(
                    r"Injection End Time (GPS s)",
                    r"Rec. End Time - Injection End Time (ms)")
                axes.set_title(r"End Time Accuracy in %s (%s Injections)" %
                               (instrument, waveform))
                axes.plot([
                    sim.time_at_instrument(instrument, {instrument: 0.0})
                    for sim, postcoh, far in pairs
                ], [(postcoh.get_ifo_endtime(instrument) -
                     sim.time_at_instrument(instrument, {instrument: 0.0})) *
                    1000. for sim, postcoh, far in pairs], "kx")
                yield fig, "t_acc_scatter_%s_%s" % (waveform,
                                                    instrument), False

                fig, axes = create_plot(
                    r"Rec. End Time - Injection End Time (ms)", "Number")
                axes.set_title(r"End Time Accuracy in %s (%s Injections)" %
                               (instrument, waveform))
                hist(
                    numpy.array([
                        float(
                            postcoh.get_ifo_endtime(instrument) -
                            sim.time_at_instrument(instrument,
                                                   {instrument: 0.0})) * 1000.
                        for sim, postcoh, far in pairs
                    ]), axes)
                yield fig, "t_acc_hist_%s_%s" % (waveform, instrument), False

                fig, axes = create_plot(
                    r"Injection $D_{\mathrm{eff}}$ ($\mathrm{Mpc}$)",
                    r"(Rec. $D_{\mathrm{eff}}$ - Injection $D_{\mathrm{eff}}$) / Injection $D_{\mathrm{eff}}$"
                )
                axes.set_title(
                    r"Fractional Effective Distance Accuracy in %s (%s Injections)"
                    % (instrument, waveform))
                axes.semilogx([
                    sim.get_eff_dist(instrument) for sim, postcoh, far in pairs
                ], [(postcoh.get_eff_distance(instrument) -
                     sim.get_eff_dist(instrument)) /
                    sim.get_eff_dist(instrument)
                    for sim, postcoh, far in pairs], "kx")
                yield fig, "deff_acc_frac_scatter_%s_%s" % (waveform,
                                                            instrument), False

                fig, axes = create_plot(
                    r"(Rec. $D_{\mathrm{eff}}$ - Injection $D_{\mathrm{eff}}$) / Injection $D_{\mathrm{eff}}$",
                    "Number")
                axes.set_title(
                    r"Fractional Effective Distance Accuracy in %s (%s Injections)"
                    % (instrument, waveform))
                hist(
                    numpy.array([(postcoh.get_eff_distance(instrument) -
                                  sim.get_eff_dist(instrument)) /
                                 sim.get_eff_dist(instrument)
                                 for sim, postcoh, far in pairs]), axes)
                yield fig, "deff_acc_frac_hist_%s_%s" % (waveform,
                                                         instrument), False

                if postcoh.get_eff_distance(instrument) > 0.0:
                    fig, axes = create_plot(
                        r"(Rec. $1/D_{\mathrm{eff}}$ - Injection $1/D_{\mathrm{eff}}$) / Injection $1/D_{\mathrm{eff}}$",
                        "Number")
                    axes.set_title(
                        r"Fractional Effective Amplitude Accuracy in %s (%s Injections)"
                        % (instrument, waveform))
                    hist(
                        numpy.array([
                            (1. / postcoh.get_eff_distance(instrument) -
                             1. / sim.get_eff_dist(instrument)) /
                            (1. / sim.get_eff_dist(instrument))
                            for sim, postcoh, far in pairs
                        ]), axes)
                    yield fig, "deff_acc_frac_inv_hist_%s_%s" % (
                        waveform, instrument), False

                fig, axes = create_plot(r"Inj. $\chi$", r"Rec. $\chi$")
                axes.set_title(
                    r"Effective Spin Accuracy in %s (%s Injections)" %
                    (instrument, waveform))
                axes.plot([sim.chi for sim, postcoh, far in pairs],
                          [postcoh.chi for sim, postcoh, far in pairs], "kx")
                yield fig, "chi_acc_scatter_%s_%s" % (waveform,
                                                      instrument), False

                fig, axes = create_plot(r"Inj. SNR", r"Rec. SNR")
                axes.set_title(r"SNR Recovery in %s (%s Injections)" %
                               (instrument, waveform))
                if max([sim.alpha4 for sim, postcoh, far in pairs]) > 20:
                    axes.loglog([
                        sim.get_exp_snr(instrument)
                        for sim, postcoh, far in pairs
                    ], [
                        postcoh.get_snglsnr(instrument)
                        for sim, postcoh, far in pairs
                    ], "kx")
                else:
                    axes.plot([
                        sim.get_exp_snr(instrument)
                        for sim, postcoh, far in pairs
                    ], [
                        postcoh.get_snglsnr(instrument)
                        for sim, postcoh, far in pairs
                    ], "kx")
                yield fig, "snr_rec_scatter_%s_%s" % (waveform,
                                                      instrument), False


#
# =============================================================================
#
#			   Background --- Single Instrument
#
# =============================================================================
#


class BackgroundPlots(object):
    def __init__(self, ifos, bgname, njob):
        self.proc = []
        self.bgname = bgname
        self.ifos = ifos
        self.njob = njob

    def add_contents(self, contents):
        # do nothing
        self.output = "%s_08.png" % self.bgname.strip('.xml.gz')
        self.ifo_list = re.findall('..', self.ifos)
        self.snglifo_output = {}
        for ifo in self.ifo_list:
            self.snglifo_output[ifo] = "%s_%s_08.png" % (
                self.bgname.strip('.xml.gz'), ifo)

    def __call_background_plot_func(self, ifos, stats_fname, zerolag_fname,
                                    cohsnr, cmbchisq, output, njob):
        cmd = []
        cmd += ["gstlal_cohfar_plot_stats"]
        cmd += ["--output", output]
        cmd += ["--input-stats", stats_fname]
        cmd += ["--zerolag-format", "single"]
        cmd += ["--cohsnr", str(cohsnr)]
        cmd += ["--cmbchisq", str(cmbchisq)]
        cmd += ["--ifos", ifos]
        cmd += ["--far-factor", str(njob)]
        if zerolag_fname:
            cmd += ["--input-zerolag", zerolag_fname]
        print cmd
        proc = subprocess.Popen(cmd)
        proc_out, proc_err = proc.communicate()

    def finish(self):
        # plot the point cohsnr = 8, chisq = 1
        self.__call_background_plot_func(self.ifos, self.bgname, None, 8, 1,
                                         self.output, self.njob)
        for ifo in self.ifo_list:
            self.__call_background_plot_func(ifo, self.bgname, None, 8, 1,
                                             self.snglifo_output[ifo],
                                             self.njob)
        yield None, None, None


#
# =============================================================================
#
#			   Background vs. Injections --- Single Instrument
#
# =============================================================================
#


class BackgroundVsInjectionPlots(object):
    class Points(object):
        def __init__(self):
            self.snr = []
            self.chi2 = []
            self.bankveto = []
            self.spin = []

    def __init__(self):
        self.injections = {}
        self.background = {}
        self.zerolag = {}

    def add_contents(self, contents):
        if contents.sim_inspiral_table is None:
            # non-injections file
            for instrument, snr, chi2, bankveto, is_background in contents.connection.cursor(
            ).execute(
                    """
SELECT
	sngl_inspiral.ifo,
	sngl_inspiral.snr,
	sngl_inspiral.chisq,
	sngl_inspiral.bank_chisq / bank_chisq_dof,
	EXISTS (
		SELECT
			*
		FROM
			time_slide
		WHERE
			time_slide.time_slide_id == coinc_event.time_slide_id
			AND time_slide.offset != 0
	)
FROM
	coinc_event
	JOIN coinc_event_map ON (
		coinc_event_map.coinc_event_id == coinc_event.coinc_event_id
	)
	JOIN sngl_inspiral ON (
		coinc_event_map.table_name == 'sngl_inspiral'
		AND coinc_event_map.event_id == sngl_inspiral.event_id
	)
WHERE
	coinc_event.coinc_def_id == ?
			""", (contents.ii_definer_id, )):
                if is_background:
                    if instrument not in self.background:
                        self.background[
                            instrument] = BackgroundVsInjectionPlots.Points()
                    self.background[instrument].snr.append(snr)
                    self.background[instrument].chi2.append(chi2)
                    self.background[instrument].bankveto.append(bankveto)
                else:
                    if instrument not in self.zerolag:
                        self.zerolag[
                            instrument] = BackgroundVsInjectionPlots.Points()
                    self.zerolag[instrument].snr.append(snr)
                    self.zerolag[instrument].chi2.append(chi2)
                    self.zerolag[instrument].bankveto.append(bankveto)
        else:
            # injections file
            for instrument, snr, chi2, bankveto, end_time, spin in contents.connection.cursor(
            ).execute("""
SELECT
	sngl_inspiral.ifo,
	sngl_inspiral.snr,
	sngl_inspiral.chisq,
	sngl_inspiral.bank_chisq / bank_chisq_dof,
	sngl_inspiral.end_time + sngl_inspiral.end_time_ns * 1e-9,
	sim.spin1x * sim.spin1x + sim.spin1y * sim.spin1y + sim.spin1z * sim.spin1z + sim.spin2x * sim.spin2x + sim.spin2y * sim.spin2y + sim.spin2z * sim.spin2z
FROM
	sim_coinc_map
	JOIN coinc_event_map ON (
		coinc_event_map.coinc_event_id == sim_coinc_map.coinc_event_id
	)
	JOIN sngl_inspiral ON (
		coinc_event_map.table_name == 'sngl_inspiral'
		AND coinc_event_map.event_id == sngl_inspiral.event_id
	)
	JOIN sim_inspiral AS sim ON sim.simulation_id == sim_coinc_map.simulation_id
			"""):
                if end_time in contents.seglists[instrument]:
                    if instrument not in self.injections:
                        self.injections[
                            instrument] = BackgroundVsInjectionPlots.Points()
                    self.injections[instrument].snr.append(snr)
                    self.injections[instrument].chi2.append(chi2)
                    self.injections[instrument].bankveto.append(bankveto)
                    self.injections[instrument].spin.append((spin / 2.)**.5)

    def finish(self):
        for instrument in set(self.injections) | set(self.background) | set(
                self.zerolag):
            self.injections.setdefault(instrument,
                                       BackgroundVsInjectionPlots.Points())
            self.background.setdefault(instrument,
                                       BackgroundVsInjectionPlots.Points())
            self.zerolag.setdefault(instrument,
                                    BackgroundVsInjectionPlots.Points())
        for instrument in self.background:
            fig, axes = create_plot(r"$\rho$", r"$\chi^{2}$")
            axes.set_title(r"$\chi^{2}$ vs.\ $\rho$ in %s (Closed Box)" %
                           instrument)

            for (spinstart, spinstop) in [(0, 0.1), (0.1, 0.2), (0.2, 0.3),
                                          (0.3, 0.4), (0.4, 0.5), (0.5, 0.6),
                                          (0.6, 1.0)][::-1]:
                injsnr = numpy.array([
                    self.injections[instrument].snr[n]
                    for n in range(len(self.injections[instrument].snr))
                    if self.injections[instrument].spin[n] >= spinstart
                    and self.injections[instrument].spin[n] < spinstop
                ])
                injchi2 = numpy.array([
                    self.injections[instrument].chi2[n]
                    for n in range(len(self.injections[instrument].snr))
                    if self.injections[instrument].spin[n] >= spinstart
                    and self.injections[instrument].spin[n] < spinstop
                ])
                axes.loglog(injsnr,
                            injchi2,
                            '.',
                            label="Inj $|s|$=%.1f" % spinstart)

            axes.loglog(self.background[instrument].snr,
                        self.background[instrument].chi2,
                        "kx",
                        label="Background")
            axes.legend(loc="upper left")
            yield fig, "chi2_vs_rho_%s" % instrument, False

            fig, axes = create_plot(r"$\rho$", r"$\chi^{2}$")
            axes.set_title(r"$\chi^{2}$ vs.\ $\rho$ in %s" % instrument)
            for (spinstart, spinstop) in [(0, 0.1), (0.1, 0.2), (0.2, 0.3),
                                          (0.3, 0.4), (0.4, 0.5), (0.5, 0.6),
                                          (0.6, 1.0)][::-1]:
                injsnr = numpy.array([
                    self.injections[instrument].snr[n]
                    for n in range(len(self.injections[instrument].snr))
                    if self.injections[instrument].spin[n] >= spinstart
                    and self.injections[instrument].spin[n] < spinstop
                ])
                injchi2 = numpy.array([
                    self.injections[instrument].chi2[n]
                    for n in range(len(self.injections[instrument].snr))
                    if self.injections[instrument].spin[n] >= spinstart
                    and self.injections[instrument].spin[n] < spinstop
                ])
                axes.loglog(injsnr,
                            injchi2,
                            '.',
                            label="Inj $|s|$=%.1f" % spinstart)
            axes.loglog(self.background[instrument].snr,
                        self.background[instrument].chi2,
                        "kx",
                        label="Background")
            axes.loglog(self.zerolag[instrument].snr,
                        self.zerolag[instrument].chi2,
                        "bx",
                        label="Zero-lag")
            axes.legend(loc="upper left")
            yield fig, "chi2_vs_rho_%s" % instrument, True


#
# =============================================================================
#
#			   Background vs. Injections --- Multi Instrument
#
# =============================================================================
#


class BackgroundVsInjectionPlotsMulti(object):
    class Points(object):
        def __init__(self):
            self.background_snreff = []
            self.injections_snreff = []
            self.zerolag_snreff = []
            self.background_deff = []
            self.injections_deff = []
            self.zerolag_deff = []

    def __init__(self, snrfactor):
        self.snrfactor = snrfactor
        self.points = {}

    def add_contents(self, contents):
        if contents.sim_inspiral_table is None:
            # non-injections file
            for values in contents.connection.cursor().execute(
                    """
SELECT
	sngl_inspiral_x.*,
	sngl_inspiral_y.*,
	EXISTS (
		SELECT
			*
		FROM
			time_slide
		WHERE
			time_slide.time_slide_id == coinc_event.time_slide_id
			AND time_slide.offset != 0
	)
FROM
	coinc_event
	JOIN coinc_event_map AS coinc_event_map_x ON (
		coinc_event_map_x.coinc_event_id == coinc_event.coinc_event_id
	)
	JOIN sngl_inspiral AS sngl_inspiral_x ON (
		coinc_event_map_x.table_name == 'sngl_inspiral'
		AND coinc_event_map_x.event_id == sngl_inspiral_x.event_id
	)
	JOIN coinc_event_map AS coinc_event_map_y ON (
		coinc_event_map_y.coinc_event_id == coinc_event.coinc_event_id
	)
	JOIN sngl_inspiral AS sngl_inspiral_y ON (
		coinc_event_map_y.table_name == 'sngl_inspiral'
		AND coinc_event_map_y.event_id == sngl_inspiral_y.event_id
	)
	JOIN postcoh ON (
		postcoh.coinc_event_id == coinc_event.coinc_event_id
	)
WHERE
	coinc_event.coinc_def_id == ?
	AND sngl_inspiral_x.ifo > sngl_inspiral_y.ifo
			""", (contents.ii_definer_id, )):
                x = contents.sngl_inspiral_table.row_from_cols(values)
                y = contents.sngl_inspiral_table.row_from_cols(
                    values[len(contents.sngl_inspiral_table.columnnames):])
                is_background, = values[-1:]
                instrument_pair = (x.ifo, y.ifo)
                if instrument_pair not in self.points:
                    self.points[
                        instrument_pair] = BackgroundVsInjectionPlotsMulti.Points(
                        )
                if is_background:
                    self.points[instrument_pair].background_snreff.append(
                        (x.get_effective_snr(fac=self.snrfactor),
                         y.get_effective_snr(fac=self.snrfactor)))
                    self.points[instrument_pair].background_deff.append(
                        (x.eff_distance, y.eff_distance))
                else:
                    self.points[instrument_pair].zerolag_snreff.append(
                        (x.get_effective_snr(fac=self.snrfactor),
                         y.get_effective_snr(fac=self.snrfactor)))
                    self.points[instrument_pair].zerolag_deff.append(
                        (x.eff_distance, y.eff_distance))
        else:
            # injections file
            for values in contents.connection.cursor().execute("""
SELECT
	sngl_inspiral_x.*,
	sngl_inspiral_y.*
FROM
	sim_coinc_map
	JOIN coinc_event_map AS coinc_event_map_x ON (
		coinc_event_map_x.coinc_event_id == sim_coinc_map.coinc_event_id
	)
	JOIN sngl_inspiral AS sngl_inspiral_x ON (
		coinc_event_map_x.table_name == 'sngl_inspiral'
		AND coinc_event_map_x.event_id == sngl_inspiral_x.event_id
	)
	JOIN coinc_event_map AS coinc_event_map_y ON (
		coinc_event_map_y.coinc_event_id == sim_coinc_map.coinc_event_id
	)
	JOIN sngl_inspiral AS sngl_inspiral_y ON (
		coinc_event_map_y.table_name == 'sngl_inspiral'
		AND coinc_event_map_y.event_id == sngl_inspiral_y.event_id
	)
WHERE
	sngl_inspiral_x.ifo > sngl_inspiral_y.ifo
			"""):
                x = contents.sngl_inspiral_table.row_from_cols(values)
                y = contents.sngl_inspiral_table.row_from_cols(
                    values[len(contents.sngl_inspiral_table.columnnames):])
                instrument_pair = (x.ifo, y.ifo)
                if instrument_pair not in self.points:
                    self.points[
                        instrument_pair] = BackgroundVsInjectionPlotsMulti.Points(
                        )
                self.points[instrument_pair].injections_snreff.append(
                    (x.get_effective_snr(fac=self.snrfactor),
                     y.get_effective_snr(fac=self.snrfactor)))
                self.points[instrument_pair].injections_deff.append(
                    (x.eff_distance, y.eff_distance))

    def finish(self):
        for (x_instrument, y_instrument), points in self.points.items():
            fig, axes = create_plot(
                r"$\rho_{\mathrm{eff}}$ in %s" % x_instrument,
                r"$\rho_{\mathrm{eff}}$ in %s" % y_instrument,
                aspect=1.0)
            axes.set_title(
                r"Effective SNR in %s vs.\ %s (SNR Factor = %g) (Closed Box)" %
                (y_instrument, x_instrument, self.snrfactor))
            axes.loglog([x for x, y in points.injections_snreff],
                        [y for x, y in points.injections_snreff], "rx")
            axes.loglog([x for x, y in points.background_snreff],
                        [y for x, y in points.background_snreff], "kx")
            axes.legend(("Injections", "Background"), loc="lower right")
            yield fig, "rho_%s_vs_%s" % (y_instrument, x_instrument), False

            fig, axes = create_plot(
                r"$\rho_{\mathrm{eff}}$ in %s" % x_instrument,
                r"$\rho_{\mathrm{eff}}$ in %s" % y_instrument,
                aspect=1.0)
            axes.set_title(r"Effective SNR in %s vs.\ %s (SNR Factor = %g)" %
                           (y_instrument, x_instrument, self.snrfactor))
            axes.loglog([x for x, y in points.injections_snreff],
                        [y for x, y in points.injections_snreff], "rx")
            axes.loglog([x for x, y in points.background_snreff],
                        [y for x, y in points.background_snreff], "kx")
            axes.loglog([x for x, y in points.zerolag_snreff],
                        [y for x, y in points.zerolag_snreff], "bx")
            axes.legend(("Injections", "Background", "Zero-lag"),
                        loc="lower right")
            yield fig, "rho_%s_vs_%s" % (y_instrument, x_instrument), True

            fig, axes = create_plot(r"$D_{\mathrm{eff}}$ in %s" % x_instrument,
                                    r"$D_{\mathrm{eff}}$ in %s" % y_instrument,
                                    aspect=1.0)
            axes.set_title(r"Effective Distance in %s vs.\ %s (Closed Box)" %
                           (y_instrument, x_instrument))
            axes.loglog([x for x, y in points.injections_deff],
                        [y for x, y in points.injections_deff], "rx")
            axes.loglog([x for x, y in points.background_deff],
                        [y for x, y in points.background_deff], "kx")
            axes.legend(("Injections", "Background"), loc="lower right")
            yield fig, "deff_%s_vs_%s" % (y_instrument, x_instrument), False

            fig, axes = create_plot(r"$D_{\mathrm{eff}}$ in %s" % x_instrument,
                                    r"$D_{\mathrm{eff}}$ in %s" % y_instrument,
                                    aspect=1.0)
            axes.set_title(r"Effective Distance in %s vs.\ %s" %
                           (y_instrument, x_instrument))
            axes.loglog([x for x, y in points.injections_deff],
                        [y for x, y in points.injections_deff], "rx")
            axes.loglog([x for x, y in points.background_deff],
                        [y for x, y in points.background_deff], "kx")
            axes.loglog([x for x, y in points.zerolag_deff],
                        [y for x, y in points.zerolag_deff], "bx")
            axes.legend(("Injections", "Background", "Zero-lag"),
                        loc="lower right")
            yield fig, "deff_%s_vs_%s" % (y_instrument, x_instrument), True


#
# =============================================================================
#
#						   Rate vs. Threshold Plots
#
# =============================================================================
#


def sigma_region(mean, nsigma):
    return numpy.concatenate((mean - nsigma * numpy.sqrt(mean),
                              (mean + nsigma * numpy.sqrt(mean))[::-1]))


def create_farplot(axes,
                   zerolag_stats,
                   expected_count_x,
                   expected_count_y,
                   is_open_box,
                   xlim=(None, None),
                   max_events=1000):
    #
    # isolate relevent data
    #

    zerolag_stats = zerolag_stats[:max_events]

    #
    # background.  uncomment the two lines to make the background
    # stair-step-style like the observed counts
    #

    #expected_count_x = expected_count_x.repeat(2)[1:]
    #expected_count_y = expected_count_y.repeat(2)[:-1]
    line1, = axes.plot(expected_count_x, expected_count_y, 'k--', linewidth=1)

    #
    # error bands
    #

    expected_count_x = numpy.concatenate(
        (expected_count_x, expected_count_x[::-1]))
    line2, = axes.fill(expected_count_x,
                       sigma_region(expected_count_y,
                                    3.0).clip(0.001, max_events),
                       alpha=0.25,
                       facecolor=[0.75, 0.75, 0.75])
    line3, = axes.fill(expected_count_x,
                       sigma_region(expected_count_y,
                                    2.0).clip(0.001, max_events),
                       alpha=0.25,
                       facecolor=[0.5, 0.5, 0.5])
    line4, = axes.fill(expected_count_x,
                       sigma_region(expected_count_y,
                                    1.0).clip(0.001, max_events),
                       alpha=0.25,
                       facecolor=[0.25, 0.25, 0.25])

    #
    # zero-lag
    #

    N = numpy.arange(1., len(zerolag_stats) + 1., dtype="double")
    line5, = axes.plot(zerolag_stats.repeat(2)[1:],
                       N.repeat(2)[:-1],
                       'k',
                       linewidth=2)

    #
    # legend
    #

    if is_open_box:
        axes.legend((line5, line1, line4, line3, line2),
                    ("Zero-lag", r"$\langle N \rangle$",
                     r"$\pm\sqrt{\langle N \rangle}$",
                     r"$\pm 2\sqrt{\langle N \rangle}$",
                     r"$\pm 3\sqrt{\langle N \rangle}$"),
                    loc="upper right")
    else:
        axes.legend((line5, line1, line4, line3, line2),
                    (r"$\pi$ shift", r"$\langle N \rangle$",
                     r"$\pm\sqrt{\langle N \rangle}$",
                     r"$\pm 2\sqrt{\langle N \rangle}$",
                     r"$\pm 3\sqrt{\langle N \rangle}$"),
                    loc="upper right")

    #
    # adjust bounds of plot
    #

    xlim = max(zerolag_stats.min(), xlim[0]), (2.**math.ceil(
        math.log(zerolag_stats.max(), 2.)) if xlim[1] is None else xlim[1])
    axes.set_xlim(xlim)
    axes.set_ylim((0.001, 10.**math.ceil(math.log10(max_events))))


class RateVsThreshold(object):
    def __init__(self, tag):
        self.tag = tag
        self.zerolag_snr = []
        self.zerolag_rank = []
        self.zerolag_far = []
        self.zerolag_fap = []
        self.bg_snr = []
        self.bg_rank = []
        self.bg_far = []
        self.bg_fap = []
        self.livetime = 0

    def reset_tag(self, tag):
        self.tag = tag

    def add_contents(self, contents):
        if contents.sim_inspiral_table is not None:
            # skip injection documents
            return

        self.livetime = contents.segs_livetime
        # FIXME: first should be rank
        select_candidates = contents.connection.cursor().execute("""
SELECT
	postcoh.rank,
	postcoh.far,
	postcoh.fap,
	postcoh.cohsnr
FROM
	postcoh
WHERE
	postcoh.cohsnr >= 4 AND postcoh.far > 0.0
		""").fetchall()
        if self.tag == "noninj":
            for (rank, far, fap, snr) in select_candidates:
                self.zerolag_rank.append(rank)
                self.zerolag_far.append(far)
                self.zerolag_fap.append(fap)
                self.zerolag_snr.append(snr)
        elif self.tag == "shift":
            for (rank, far, fap, snr) in select_candidates:
                self.bg_rank.append(rank)
                self.bg_far.append(far)
                self.bg_fap.append(fap)
                self.bg_snr.append(snr)

    def finish(self):
        if self.bg_snr:
            try:
                fig, axes = create_plot(x_label=r"SNR", y_label=r"rank")
                axes.loglog(self.bg_snr,
                            self.bg_rank,
                            "kx",
                            label="Background")
                axes.legend(loc="upper left")
                axes.set_title(r"rank vs.\ SNR Scatter Plot (Closed Box)")
                yield fig, "rank_vs_snr", False
            except:  # snr or rank has 0 values
                pass

        if self.bg_snr and self.zerolag_snr:
            try:
                fig, axes = create_plot(x_label=r"SNR", y_label=r"rank")
                axes.loglog(self.bg_snr,
                            self.bg_rank,
                            "kx",
                            label="Background")
                axes.loglog(self.zerolag_snr,
                            self.zerolag_rank,
                            "bx",
                            label="Zero-lag")
                axes.legend(loc="upper left")
                axes.set_title(r"rank vs.\ SNR Scatter Plot")
                yield fig, "rank_vs_snr", True
            except:  # snr or rank has 0 values
                pass

        for ranks, fars, is_open_box in [(self.zerolag_rank, self.zerolag_far,
                                          True),
                                         (self.bg_rank, self.bg_far, False)]:
            if fars:
                fig, axes = create_plot(None, r"Number of Events")
                axes.loglog()
                # fars in ascending order --> ifars in descending order
                zerolag_stats = 1. / numpy.array(sorted(fars))
                expected_count_y = numpy.logspace(
                    -7, numpy.log10(len(zerolag_stats)), 1000)
                expected_count_x = self.livetime / expected_count_y
                create_farplot(axes,
                               zerolag_stats,
                               expected_count_x,
                               expected_count_y,
                               is_open_box,
                               xlim=(None, 2000. * self.livetime))
                if is_open_box:
                    axes.set_title(
                        r"Event Count vs.\ Inverse False-Alarm Rate Threshold")
                else:
                    axes.set_title(
                        r"Event Count vs.\ Inverse False-Alarm Rate Threshold (Closed Box)"
                    )
                axes.set_xlabel(r"Inverse False-Alarm Rate (s)")
                yield fig, "count_vs_ifar", is_open_box

            # if we have some values in ranks
            if ranks:
                fig, axes = create_plot(None, r"Number of Events")
                axes.semilogy()

                zerolag_stats = numpy.array(sorted(ranks, reverse=True))

                # we want to plot FAR(ln L) * livetime vs.
                # ln L, but we don't have access to the
                # ranking statistic data file where that
                # function is encoded.  instead, we rely on
                # the FARs stored in each coinc, together
                # with the ln L assigned to each coinc, to
                # provide us with a collection of samples
                # of that function.  to get more points, we
                # combine data from the zero-lag and
                # background coincs.  in the future,
                # perhaps this program could be provided
                # with the marginalized ranking statistic
                # PDF data file

                expected_count_x = self.zerolag_rank + self.bg_rank
                order = range(len(expected_count_x))
                order.sort(key=lambda i: expected_count_x[i], reverse=True)
                expected_count_x = numpy.array(expected_count_x)[order]
                expected_count_y = numpy.array(
                    self.zerolag_far + self.bg_far)[order] * self.livetime

                create_farplot(axes,
                               zerolag_stats,
                               expected_count_x,
                               expected_count_y,
                               is_open_box,
                               xlim=(None, 23.),
                               max_events=10000)
                if is_open_box:
                    axes.set_title(
                        r"Event Count vs.\ Ranking Statistic Threshold")
                else:
                    axes.set_title(
                        r"Event Count vs.\ Ranking Statistic Threshold (Closed Box)"
                    )
                axes.set_xlabel(r"$\ln \Lambda$")
                yield fig, "count_vs_rank", is_open_box


#
# =============================================================================
#
#									 Main
#
# =============================================================================
#

#
# Parse command line
#

options, filenames = parse_command_line()

#
# Initialize plots
#

# how many there could be, so we know how many digits for the filenames


def setup_plot(dbname, plot_group, options, user_tag, wiki):
    working_filename = dbtables.get_connection_filename(
        dbname, tmp_path=options.tmp_space, verbose=options.verbose)
    connection = sqlite3.connect(working_filename)
    contents = CoincDatabase(
        connection,
        options.segments_name,
        veto_segments_name=options.vetoes_name,
        verbose=options.verbose,
        plotsummary_json=os.path.split(dbname)[-1].replace(".sqlite",
                                                           "").replace(
                                                               ".tmp", ""),
        wiki=wiki,
        base=os.path.join(options.output_dir, user_tag))
    if contents.sim_inspiral_table is not None:
        create_sim_coinc_view(connection)
    for (n, plot) in plot_group:
        if options.verbose:
            print >> sys.stderr, "adding to plot group %d %s ..." % (
                n, PlotDescriptionMap[n])
        plot.add_contents(contents)
    connection.close()
    dbtables.discard_connection_filename(dbname,
                                         working_filename,
                                         verbose=options.verbose)
    return contents


def finish_plot(contents, plot_group, options, user_tag):
    for (n, plot) in plot_group:
        for (fig, filename_fragment, is_open_box) in plot.finish():
            for format in options.format:
                if filename_fragment and fig:
                    filename_template = T050017_filename(
                        options.ifos,
                        "GSTLAL_INSPIRAL_POSTCOHSPIIR_PLOTSUMMARY_%s_%02d_%s_%s",
                        contents.seglists.extent_all(),
                        "%s",
                        path=options.output_dir)
                    filename = filename_template % (
                        user_tag, n, filename_fragment,
                        ("openbox" if is_open_box else "closedbox"), format)
                    if options.verbose:
                        print >> sys.stderr, "writing %s ..." % filename
                    fig.savefig(filename)


wiki = open(os.path.join(options.output_dir, "%s" % "plotsummary.txt"), "w")

PlotDescriptionMap = {
    11: SegmentsTable.__name__,
    0: SummaryTable.__name__,
    1: MissedFoundPlots.__name__,
    2: ParameterAccuracyPlots.__name__,
    3: BackgroundVsInjectionPlots.__name__,
    4: BackgroundVsInjectionPlotsMulti.__name__,
    5: RateVsThreshold.__name__,
    6: InjectionParameterDistributionPlots.__name__,
    7: ROCPlots.__name__,
    8: BackgroundPlots.__name__
}

if options.noninj_database:
    plots = []
    base = os.path.join(options.output_dir, options.noninj_user_tag)
    plots.append(SegmentsTable(base))
    plots.append(SummaryTable("noninj"))
    # need the shift database to plot rates, see shift
    rate_plot = RateVsThreshold("noninj")
    plots.append(rate_plot)
    plots.append(
        BackgroundPlots(options.background_ifos, options.background_xml,
                        options.njob))
    plot_group = zip([11, 0, 5, 8], plots)
    dbname = options.noninj_database
    contents = setup_plot(dbname, plot_group, options, options.noninj_user_tag,
                          wiki)
    finish_plot(contents, plot_group, options, options.noninj_user_tag)
    del contents

if options.shift_database:
    plots = []
    base = os.path.join(options.output_dir, options.shift_user_tag)
    plots.append(SegmentsTable(base))
    plots.append(SummaryTable("shift"))
    if rate_plot:
        rate_plot.reset_tag("shift")
    else:
        rate_plot = RateVsThreshold("shift")
    plots.append(rate_plot)
    plot_group = zip([11, 0, 5], plots)
    dbname = options.shift_database
    contents = setup_plot(dbname, plot_group, options, options.shift_user_tag,
                          wiki)
    finish_plot(contents, plot_group, options, options.shift_user_tag)
    del contents

if options.inj_database:
    for (inj_name, tag_name) in zip(options.inj_database.split(","),
                                    options.inj_user_tag.split(",")):
        plots = []
        base = os.path.join(options.output_dir, tag_name)
        plots.append(MissedFoundPlots(far_thresh=options.far_threshold))
        plots.append(ParameterAccuracyPlots(far_thresh=options.far_threshold))
        plots.append(InjectionParameterDistributionPlots())
        plots.append(ROCPlots())
        plot_group = zip([1, 2, 6, 7], plots)
        dbname = inj_name
        contents = setup_plot(dbname, plot_group, options, tag_name, wiki)
        finish_plot(contents, plot_group, options, tag_name)
        del contents

#
# Process files
#

# noninj database
#
# Finish and write plots, deleting them as we go to save memory
#
