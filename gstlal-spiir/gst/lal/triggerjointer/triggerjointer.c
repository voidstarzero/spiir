/*
 * Copyright (C) 2020 Tom Ameldia, Qi Chu <qi.chu@ligo.org>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

/* This element will fillin (synchronize) the trigger table generated by
 * post-coherent search from more sensitive detectors
 * with snr peaks or snippet from bypassed less sensitive detectors  
 * TODO: sky localization
 * mix sink type gstreamer element reference: rtsp/gstrtpdec.c in gst-plugin-good
 * collect data and alignment, and flag gap reference: postcoh
 */

#include <triggerjointer/triggerjointer.h>
#include <math.h>

#define GST_CAT_DEFAULT triggerjointer_debug
GST_DEBUG_CATEGORY_STATIC(GST_CAT_DEFAULT);

static void additional_initializations(GType type) {
    GST_DEBUG_CATEGORY_INIT(GST_CAT_DEFAULT, "triggerjointer", 0,
                            "SPIIR postcoh trigger jointer element");
}

GST_BOILERPLATE_FULL(TriggerJointer,
                     trigger_jointer,
                     GstElement,
                     GST_TYPE_ELEMENT,
                     additional_initializations);

/* store the gap infomation of the bypassed ifos*/
typedef struct flag_segment {
    GstClockTime start, stop;
    gboolean is_gap; // GAP true, non-GAP, false
} FlagSegment;

static gboolean need_flag_gap(TriggerJointerCollectData *data,
                              GstClockTime start,
                              GstClockTime stop) {
    GstClockTime dur_gap = 0, dur_buf = stop - start;
    gboolean need_flush   = FALSE;
    GArray *flag_segments = data->flag_segments;
    int i, flush_len = 0;
    FlagSegment *this_segment =
      &((FlagSegment *)flag_segments->data)[flag_segments->len - 1];
    /* make sure the last segment always later than the outbuf */
	if (this_segment->stop < stop) {
		GST_DEBUG_OBJECT(data, "segment flag invalid this segment stop %" GST_TIME_FORMAT
				", required stop %" GST_TIME_FORMAT, GST_TIME_ARGS(this_segment->stop),
				GST_TIME_ARGS(stop));
	}
    g_assert(this_segment->stop >= stop);

    for (i = 0; i < flag_segments->len; i++) {
        this_segment = &((FlagSegment *)flag_segments->data)[i];
        /*		| start				| stop
         *									| this_start
         *(1) | s | e (2)
         * | s							| e
         * | s		| e
         *            |s | e
         *            |s				| e
         */
        if (this_segment->start >= stop) break;
        if (this_segment->stop <= start) {
            need_flush = TRUE;
            flush_len  = i - 1;
            continue;
        }
        if (this_segment->start <= start && this_segment->stop >= stop) {
            dur_gap += this_segment->is_gap ? dur_buf : 0;
            continue;
        }

        if (this_segment->start <= start && this_segment->stop < stop) {
            dur_gap += this_segment->is_gap ? this_segment->stop - start : 0;
            continue;
        }
        if (this_segment->start > start && this_segment->stop <= stop) {
            dur_gap += this_segment->is_gap
                         ? this_segment->stop - this_segment->start
                         : 0;
            continue;
        }
        if (this_segment->start > start && this_segment->stop > stop) {
            dur_gap += this_segment->is_gap ? stop - this_segment->start : 0;
            continue;
        }
    }
    if (need_flush && flush_len > 0)
        g_array_remove_range(flag_segments, 0, flush_len);

    if (dur_gap > dur_buf / 2 - 1e-6) return TRUE;
    else
        return FALSE;
}

static void add_flag_segment(TriggerJointerCollectData *data,
                             GstClockTime start,
                             GstClockTime stop,
                             gboolean is_gap) {
    FlagSegment new_segment = { .start  = start,
                                .stop   = stop,
                                .is_gap = is_gap };

    g_assert_cmpuint(start, <=, stop);
    GST_DEBUG_OBJECT(data,
                     "found control segment [%" GST_TIME_FORMAT
                     ", %" GST_TIME_FORMAT ") in state %d",
                     GST_TIME_ARGS(new_segment.start),
                     GST_TIME_ARGS(new_segment.stop), new_segment.is_gap);

    /* try coalescing the new segment with the most recent one */
    if (data->flag_segments->len) {
        FlagSegment *final_segment =
          &((FlagSegment *)
              data->flag_segments->data)[data->flag_segments->len - 1];
        /* if the most recent segment and the new segment have the
         * same state and they touch, merge them */
        if (final_segment->is_gap == new_segment.is_gap
            && final_segment->stop >= new_segment.start) {
            g_assert_cmpuint(new_segment.stop, >=, final_segment->stop);
            final_segment->stop = new_segment.stop;
            return;
        }
        /* otherwise, if the most recent segment had 0 length,
         * replace it entirely with the new one.  note that the
         * state carried by a zero-length segment is meaningless,
         * zero-length segments are merely interpreted as a
         * heart-beat indicating how far the control stream has
         * advanced */
        if (final_segment->stop == final_segment->start) {
            *final_segment = new_segment;
            return;
        }
    }
    /* otherwise append a new segment */
    g_array_append_val(data->flag_segments, new_segment);
}

/*
 * First linked sink pad is to receive the postcoh table, other pads are requested pads to 
 * receive SNR series
 * */
static GstStaticPadTemplate trigger_jointer_postcoh_sink_template = GST_STATIC_PAD_TEMPLATE ("postcoh_%s", // name read from python link_pads function
        GST_PAD_SINK,
        GST_PAD_REQUEST,
        GST_STATIC_CAPS("application/x-lal-postcoh")
		);

static GstStaticPadTemplate trigger_jointer_snr_sink_template = GST_STATIC_PAD_TEMPLATE ("snr_%s", // name read from python link_pads function
        GST_PAD_SINK,
        GST_PAD_REQUEST,
		GST_STATIC_CAPS("audio/x-raw-float, "
                       "rate = (int) [1, MAX], "
                       "channels = (int) [1, MAX], "
                       "endianness = (int) BYTE_ORDER, "
                       "width = (int) 32")
		);

/* copied from trigger_jointer plugin
 * forwards the event to all sinkpads, takes ownership of the event
 */

typedef struct {
    GstEvent *event;
    gboolean flush;
} EventData;

static gboolean
  forward_src_event_func(GstPad *pad, GValue *ret, EventData *data) {
    GST_DEBUG_OBJECT(pad, "forward an event");
    gst_event_ref(data->event);
    if (!gst_pad_push_event(pad, data->event)) {
        /* quick hack to unflush the pads. ideally we need  a way
         * to just unflush this single collect pad */
        if (data->flush) gst_pad_send_event(pad, gst_event_new_flush_stop());
    } else {
        g_value_set_boolean(ret, TRUE);
    }
    gst_object_unref(GST_OBJECT(pad));
    return TRUE;
}

static gboolean
  forward_src_event(TriggerJointer *jointer, GstEvent *event, gboolean flush) {
    GstIterator *it;
    GValue vret    = { 0 };
    EventData data = { event, flush };
    gboolean success;

    g_value_init(&vret, G_TYPE_BOOLEAN);
    g_value_set_boolean(&vret, FALSE);

    it = gst_element_iterate_sink_pads(GST_ELEMENT(jointer));
    while (TRUE) {
        switch (gst_iterator_fold(
          it, (GstIteratorFoldFunction)forward_src_event_func, &vret, &data)) {
        case GST_ITERATOR_RESYNC:
            gst_iterator_resync(it);
            g_value_set_boolean(&vret, TRUE);
            break;

        case GST_ITERATOR_OK:
        case GST_ITERATOR_DONE: success = g_value_get_boolean(&vret); goto done;

        default: success = FALSE; goto done;
        }
    }
done:
    gst_iterator_free(it);
    gst_event_unref(event);

    return success;
}

/*
 * handle events received on the source pad
 */

static gboolean src_event(GstPad *pad, GstEvent *event) {
    TriggerJointer *jointer = TRIGGER_JOINTER(gst_pad_get_parent(pad));
    gboolean success;

    switch (GST_EVENT_TYPE(event)) {
    case GST_EVENT_SEEK: {
        gdouble rate;
        GstSeekFlags flags;
        GstSeekType curtype, endtype;
        gint64 cur, end;
        gboolean flush;

        gst_event_parse_seek(event, &rate, NULL, &flags, &curtype, &cur,
                             &endtype, &end);
        flush = flags & GST_SEEK_FLAG_FLUSH;

        /* FIXME:  copy the adder's logic re flushing */

        success = forward_src_event(jointer, event, flush);
        break;
    }

    /* events that can't be handled */
    case GST_EVENT_QOS:
    case GST_EVENT_NAVIGATION:
        gst_event_unref(event);
        success = FALSE;
        break;

    /* forward the rest out all sink pads */
    default:
        GST_DEBUG_OBJECT(jointer, "forward src event");
        success = forward_src_event(jointer, event, FALSE);
        break;
    }

    return success;
}


static GstStateChangeReturn
  trigger_jointer_change_state(GstElement *element, GstStateChange transition) {
    TriggerJointer *jointer = TRIGGER_JOINTER(element);

    switch (transition) {
    case GST_STATE_CHANGE_NULL_TO_READY: break;

    case GST_STATE_CHANGE_READY_TO_PAUSED:
        gst_collect_pads_start(jointer->collect);
        break;

    case GST_STATE_CHANGE_PAUSED_TO_PLAYING: break;

    case GST_STATE_CHANGE_PAUSED_TO_READY:
        /* need to unblock the collectpads before calling the
         * parent change_state so that streaming can finish */
        gst_collect_pads_stop(jointer->collect);
        break;

    default: break;
    }

    return GST_ELEMENT_CLASS(parent_class)->change_state(element, transition);
}

static gboolean 
sink_event(GstPad *pad, GstEvent *event) {
    TriggerJointer *jointer        = TRIGGER_JOINTER(GST_PAD_PARENT(pad));
    TriggerJointerCollectData *data = gst_pad_get_element_private(pad);
    gboolean ret                = TRUE;

    switch (GST_EVENT_TYPE(event)) {
    case GST_EVENT_NEWSEGMENT: GST_DEBUG_OBJECT(pad, "new segment"); break;
    // do not process tag.
    case GST_EVENT_TAG: gst_object_unref(event); return TRUE;
    default: break;
    }
    ret = jointer->collect_event(pad, event);
    return TRUE;
}

static void destroy_notify(TriggerJointerCollectData *data) {
    if (data) {
		if (data->ifo_name)
			free(data->ifo_name);
        if (data->adapter) {
            gst_adapter_clear(data->adapter);
            g_object_unref(data->adapter);
            data->adapter = NULL;
        }
        if (data->flag_segments) {
            g_array_unref(data->flag_segments);
            data->flag_segments = NULL;
        }
    }
}

static gboolean
trigger_jointer_set_snr_info(TriggerJointer *jointer) {
	GList *snrdata;
	GstCaps *caps;
	GstStructure *s;
	GstPad *this_pad;
	TriggerJointerCollectData *data;

   for (snrdata = jointer->collect_snrdata; snrdata;
         snrdata = g_slist_next(snrdata)) {
		data = snrdata->data;
		/* data->data is the GstCollectData, it has its managed pad */
		this_pad = (GstPad *)((data->data).pad);
		caps = GST_PAD_CAPS(this_pad);
        GST_DEBUG_OBJECT(jointer, "getting caps on pad %p of %s: %" GST_PTR_FORMAT,
                   this_pad, GST_PAD_NAME(this_pad), caps);

		/* get the caps out */
		s = gst_caps_get_structure(caps, 0);
		gst_structure_get_int(s, "width", &data->width);
        gst_structure_get_int(s, "rate", &data->rate);
        gst_structure_get_int(s, "channels", &data->channels);

	    /* bytes per sample */
        data->bps                   = (data->width / 8) * data->channels;
        GST_DEBUG_OBJECT(jointer, "get ifo_name %s, ifo_mapping %d,rate %d, channels %d, bps %d",
			data->ifo_name, data->ifo_mapping, data->rate, data->channels, data->bps);
   }
   return TRUE;
}

static GstPad *
trigger_jointer_request_new_pad(GstElement *element, GstPadTemplate *templ, const gchar *req_name)
{
    TriggerJointer *jointer = TRIGGER_JOINTER(element);

    /* create the pad */
    GstPad *newpad;
    newpad = gst_pad_new_from_template(templ, req_name);

    /* add the newpad to the element */
    if (!gst_element_add_pad(element, newpad)) {
        gst_object_unref(newpad);
		GST_DEBUG_OBJECT(element, "add %s pad faied", req_name);
        return NULL;
    }
    /* set the sink event function for the new pad */
    jointer->collect_event = (GstPadEventFunction) GST_PAD_EVENTFUNC(newpad);
    gst_pad_set_event_function(newpad, sink_event);

    /* add the new pad to the collect pads 
	 * and initialize the pad data */
    TriggerJointerCollectData *data;
    data = (TriggerJointerCollectData *)gst_collect_pads_add_pad_full(
            jointer->collect, newpad, sizeof(TriggerJointerCollectData),
            (GstCollectDataDestroyNotify) GST_DEBUG_FUNCPTR(destroy_notify));

    if (!data) {
        gst_element_remove_pad(element, newpad);
		GST_DEBUG_OBJECT(element, "get the collect data faied for %s", req_name);
        gst_object_unref(newpad);
        return NULL;
    }
	/* alignment flag for start time */
    data->is_aligned      = FALSE;
    data->aligned_offset0 = 0;
    data->next_offset     = 0;

	int j;
	/* new pad data: check if the data is snr series or table
	 * req_name for snr series is snr_%02s */
	if (strlen(req_name) == 6) {
		jointer->collect_snrdata = g_slist_append(jointer->collect_snrdata, data);
        data->is_snr = 1;
	    /* adapter to store the SNR series */
        data->adapter         = gst_adapter_new();
	    /* gap segments */
        data->flag_segments   = g_array_new(FALSE, FALSE, sizeof(FlagSegment));
        data->ifo_name = (gchar *)malloc(IFO_LEN * sizeof(gchar));
        strncpy(data->ifo_name, req_name+4, sizeof(data->ifo_name));
        for (j = 0; j < MAX_NIFO; j++) {
            if (strncmp(data->ifo_name, IFOMap[j].name, IFO_LEN)
                == 0) 
                data->ifo_mapping = j;
		}
	} else {
		jointer->collect_postcohdata = data;
		data->is_snr = 0;
        GST_DEBUG_OBJECT(element, "set postcoh collect data");
	}

    GST_DEBUG_OBJECT(element, "new pad for %s is added and initialized, it is %s SNR series",
                     req_name, data->is_snr ? "a": "NOT");
	return GST_PAD(newpad);
}

/* release the new pad when pipeline stops */
static void
trigger_jointer_release_pad(GstElement *element, GstPad *pad) {
    TriggerJointer *jointer = TRIGGER_JOINTER(element);
	/* remove from collect pads */
    gst_collect_pads_remove_pad(jointer->collect, pad);
	/* remove from snr pads */
	jointer->collect_snrdata = g_slist_remove(jointer->collect_snrdata, pad);
	/* remove from element */
    gst_element_remove_pad(element, pad);
	/* free data->ifo_name */
}

/* get the time from the postcoh table pad for synchronization */
static gboolean
  trigger_jointer_get_start_end_time(TriggerJointer *jointer,
                                     GstClockTime *tstart,
                                     GstClockTime *tend,
                                     guint64 *offset_start) {
    GstBuffer *buf;
    *tstart = GST_CLOCK_TIME_NONE;
    *tend = GST_CLOCK_TIME_NONE;

    /* invalid pads */
    g_return_val_if_fail(jointer->collect_postcohdata != NULL, FALSE);
    buf  = gst_collect_pads_peek(jointer->collect, (GstCollectData *)jointer->collect_postcohdata);

    /* eos */
    if (!buf) {
        GST_ERROR_OBJECT(jointer->collect_postcohdata, "pad:EOS");
        return FALSE;
    }
    /* invalid offset */
    if (!GST_BUFFER_OFFSET_IS_VALID(buf)
        || !GST_BUFFER_OFFSET_END_IS_VALID(buf)) {
        GST_ERROR_OBJECT(jointer,
                         "%" GST_PTR_FORMAT ": %" GST_PTR_FORMAT
                         " does not have valid offsets",
                         ((GstCollectData *)jointer->collect_postcohdata)->pad, buf);
        gst_buffer_unref(buf);
        return FALSE;
    }
    /* invalid timestamp */
    if (!GST_BUFFER_TIMESTAMP_IS_VALID(buf)
        || !GST_BUFFER_DURATION_IS_VALID(buf)) {
        GST_ERROR_OBJECT(jointer,
                         "%" GST_PTR_FORMAT ": %" GST_PTR_FORMAT
                         " does not have a valid timestamp and/or duration",
                         ((GstCollectData *)jointer->collect_postcohdata)->pad, buf);
        gst_buffer_unref(buf);
        return FALSE;
    }
	/* set the start time from the postcoh table buffer */
    *tstart = GST_BUFFER_TIMESTAMP(buf);
    *tend = GST_BUFFER_TIMESTAMP(buf) + GST_BUFFER_DURATION(buf);
    *offset_start = GST_BUFFER_OFFSET(buf);
    gst_buffer_unref(buf);

	/* sanity check */
	g_assert(*tstart != GST_CLOCK_TIME_NONE);
    return TRUE;
}

static gboolean trigger_jointer_align_collected(GstCollectPads *pads,
                                             TriggerJointer *jointer) {

    GSList *collectlist;
    TriggerJointerCollectData *data;
    GstBuffer *buf, *subbuf;
    GstClockTime t_start_cur, t_end_cur;
    gboolean all_aligned = TRUE, is_gap;
    guint64 offset_cur, offset_end_cur, buf_aligned_offset0;
    GstClockTime t0 = jointer->t0;

    GST_DEBUG_OBJECT(pads, "begin to align offset0");

    for (collectlist = pads->data; collectlist;
         collectlist = g_slist_next(collectlist)) {
        data = collectlist->data;
        if (data->is_aligned) {
            /* do not collect the buffer in this pad. wait for other pads to be
             * aligned */
            // buf = gst_collect_pads_pop(pads, (GstCollectData *)data);
            // gst_adapter_push(data->adapter, buf);
			GST_DEBUG_OBJECT(data, "already aligned %s", data->is_snr? "SNR pad": "postcoh pad");
            continue;
        }
		/* postcoh table buffer, set TRUE to is_aligned */
		if (data->is_snr == 0 && data->is_aligned == FALSE) {
			GST_DEBUG_OBJECT(data, "set postcoh pad to aligned");
			data->is_aligned = TRUE;
			continue;
		}

		/* only align buffers from snr pads to the t0 from the postcoh pad buffer */
        buf            = gst_collect_pads_pop(pads, (GstCollectData *)data);
        t_start_cur    = GST_BUFFER_TIMESTAMP(buf);
        t_end_cur      = t_start_cur + GST_BUFFER_DURATION(buf);
        offset_cur     = GST_BUFFER_OFFSET(buf);
        offset_end_cur = GST_BUFFER_OFFSET_END(buf);
        if (t_end_cur > t0) {
            is_gap =
              GST_BUFFER_FLAG_IS_SET(buf, GST_BUFFER_FLAG_GAP) ? TRUE : FALSE;
            add_flag_segment(data, t_start_cur, t_end_cur, is_gap);

            buf_aligned_offset0 = (gint)(jointer->offset0 - offset_cur);
            GST_DEBUG_OBJECT(
              data,
              "buffer aligned offset0 %u, size %u offset0 %" G_GUINT64_FORMAT
              " offset_cur %" G_GUINT64_FORMAT,
              buf_aligned_offset0,
              (offset_end_cur - offset_cur - buf_aligned_offset0)
                * data->channels * sizeof(float),
              jointer->offset0, offset_cur);
            g_assert(buf_aligned_offset0 >= 0);
            subbuf = gst_buffer_create_sub(
              buf, buf_aligned_offset0,
              (offset_end_cur - offset_cur - buf_aligned_offset0)
                * data->channels * sizeof(float));
            g_assert(subbuf);
            GST_LOG_OBJECT(
              pads,
              "Created sub buffer of (%u bytes) with timestamp "
              "%" GST_TIME_FORMAT ", duration %" GST_TIME_FORMAT
              ", offset %" G_GUINT64_FORMAT ", offset_end %" G_GUINT64_FORMAT,
              GST_BUFFER_SIZE(subbuf),
              GST_TIME_ARGS(GST_BUFFER_TIMESTAMP(subbuf)),
              GST_TIME_ARGS(GST_BUFFER_DURATION(subbuf)),
              GST_BUFFER_OFFSET(subbuf), GST_BUFFER_OFFSET_END(subbuf));

            gst_adapter_push(data->adapter, subbuf);

            data->is_aligned = TRUE;
            /* from the first buffer in the adapter, we initiate the next offset
             */
            data->next_offset = GST_BUFFER_OFFSET_END(buf);
            gst_buffer_unref(buf);
        } else {
            all_aligned = FALSE;
			GST_DEBUG_OBJECT(jointer, "snr pad not aligned, this buf end time %" GST_TIME_FORMAT 
					", need t0 %" GST_TIME_FORMAT ", wait for next turn", 
					GST_TIME_ARGS(GST_BUFFER_TIMESTAMP(buf)),
					GST_TIME_ARGS(jointer->t0));
            gst_buffer_unref(buf);
        }
    }
    return all_aligned;
}

static gboolean
trigger_jointer_set_next_tstart(GstCollectPads *pads,
                                            TriggerJointer *jointer) {

    TriggerJointerCollectData *data;
    GstBuffer *buf          = NULL;
	/* get the tstart from the current postcoh buffer queued in postcoh pad */
    buf  = gst_collect_pads_peek(jointer->collect, (GstCollectData *)jointer->collect_postcohdata);

    if (buf != NULL) { // != if(buf)
		jointer->tstart = GST_BUFFER_TIMESTAMP(buf);
        jointer->next_tstart = GST_BUFFER_TIMESTAMP(buf) + GST_BUFFER_DURATION(buf);
        gst_buffer_unref(buf);
	}
	GST_DEBUG_OBJECT(jointer, "next t start %" GST_TIME_FORMAT ", next t end %" GST_TIME_FORMAT,
			GST_TIME_ARGS(jointer->tstart), GST_TIME_ARGS(jointer->next_tstart));
    /* do nothing if it is null buffer */
    return TRUE;
}


static gboolean trigger_jointer_need_recollect(GstCollectPads *pads,
                                            TriggerJointer *jointer) {

    GSList *snrdata;
    TriggerJointerCollectData *data;
    GstBuffer *buf          = NULL;
	GstClockTime buf_end;
    gboolean need_recollect = FALSE, is_gap;
 
    for (snrdata = jointer->collect_snrdata; snrdata;
         snrdata = g_slist_next(snrdata)) {
		data = snrdata->data;
        buf  = gst_collect_pads_peek(pads, (GstCollectData *)data);
        if (buf != NULL) { // != if(buf)
            /* zerobuf remove it */
            if (GST_BUFFER_SIZE(buf) == 0) {
                GST_DEBUG_OBJECT(jointer, "bufsize is zero, need to recollect");
                gst_buffer_unref(buf);
                /* discard this buffer in collectpads so it can collect new one
                 */
                buf = gst_collect_pads_pop(pads, (GstCollectData *)data);
                gst_buffer_unref(buf);
                need_recollect = TRUE;
                continue;
            }
            buf_end = GST_BUFFER_TIMESTAMP(buf) + GST_BUFFER_DURATION(buf);
	        if (buf_end < jointer->next_tstart) {
				/* not enough data */
                /* dump this buffer in collectpads adaptor so it can collect new
                 * one */
                gst_buffer_unref(buf);
                buf    = gst_collect_pads_pop(pads, (GstCollectData *)data);
                is_gap = GST_BUFFER_FLAG_IS_SET(buf, GST_BUFFER_FLAG_GAP)
                           ? TRUE
                           : FALSE;
                add_flag_segment(data, GST_BUFFER_TIMESTAMP(buf), buf_end,
                                 is_gap);
                gst_adapter_push(data->adapter, buf);
                GST_DEBUG_OBJECT(jointer, "not enough data in snr pad, need to recollect");
                need_recollect = TRUE;
                continue;
            } else
				/* enough buffer, proceed to process function */
				GST_DEBUG_OBJECT(jointer, "enough data in snr pad, proceed to process");
				gst_buffer_unref(buf);
		}
        /* do nothing if it is null buffer */
    }
    return need_recollect;
}


static GstFlowReturn
trigger_jointer_append_coinc_snr(TriggerJointer *jointer,
		GstBuffer *postcoh_buf) {

	GSList *snrdata;
    TriggerJointerCollectData *data;
    GstBuffer *buf = NULL;
	COMPLEX_F *snglsnr;
    GstFlowReturn ret = GST_FLOW_OK;
	float one_take_dur = GST_BUFFER_DURATION(postcoh_buf)/GST_SECOND;
	gint one_take_size = 0;
	gboolean is_gap;
	int one_ifo_size = sizeof(gchar) * IFO_LEN, len_ifos = 0, nifo = 0, pad_loc = 0;
	LIGOTimeGPS cur_buftime;
	XLALINT8NSToGPS(&cur_buftime, jointer->tstart);

	int tmplt_idx, this_sample;
	float this_sec, this_nano;

	PostcohInspiralTable *trigger = (PostcohInspiralTable *) GST_BUFFER_DATA(postcoh_buf);
    PostcohInspiralTable *trigger_end =
      (PostcohInspiralTable *)(GST_BUFFER_DATA(postcoh_buf) + GST_BUFFER_SIZE(postcoh_buf));
 
    for (snrdata = jointer->collect_snrdata; snrdata;
         snrdata = g_slist_next(snrdata)) {
		data = snrdata->data;
		/* get the C pointer to point to the SNR matrix */
		one_take_size = one_take_dur * data->bps;
	    snglsnr = (COMPLEX_F *) gst_adapter_peek(data->adapter, one_take_size);
		GST_DEBUG_OBJECT(jointer, "process snr data size %d, start time %" GST_TIME_FORMAT
				", end time %" GST_TIME_FORMAT, one_take_size, GST_TIME_ARGS(jointer->tstart)
				, GST_TIME_ARGS(jointer->next_tstart));

		/* no data in adapter, do nothing */
		if (snglsnr == NULL)
			continue;

		/*
		 * check if this period of data is gap data
		 * if gap, flush this data and move on
		 */
		is_gap = need_flag_gap(data, jointer->tstart, jointer->next_tstart);

		if (is_gap) {
			/* flush the SNR matrix from the adapter */
			gst_adapter_flush(data->adapter, one_take_size);
			GST_DEBUG_OBJECT(jointer, "the snr buffer is a gap, flush it from adapter");
			continue;
		}

		/* not a gap, extend the trigger field ifos with the new ifo */
		if (trigger->ifos) {
			len_ifos = strlen(trigger->ifos);
			nifo = len_ifos/IFO_LEN;
			pad_loc = len_ifos + IFO_LEN;
		}

		/* find the coinc snr from tmplt idx
		 * and time idx */
		COMPLEX_F this_snr;
		for (; trigger < trigger_end; trigger++) {
			/* not a zerolag trigger but an entry
			 * just to indicate ifos */
			if (trigger->is_background != FLAG_FOREGROUND) 
				continue;
			/* inserting the IFO into the IFO list */
			strncpy(trigger->ifos + len_ifos, data->ifo_name, one_ifo_size);
			trigger->ifos[pad_loc] = '\0';
			/* find the sample corresponding to the end_time of the trigger */
			this_sec = trigger->end_time.gpsSeconds - cur_buftime.gpsSeconds;
			this_nano = trigger->end_time.gpsNanoSeconds - cur_buftime.gpsNanoSeconds;
			this_sample = (int)((this_sec + (float)(this_nano)/1e9) * data->rate);
			/* find the tmplt idx of the trigger */
			tmplt_idx = trigger->tmplt_idx;
			this_snr = snglsnr[tmplt_idx * data->channels + this_sample];
			trigger->snglsnr[data->ifo_mapping] = sqrt(this_snr.re*this_snr.re + this_snr.im*this_snr.im);
			trigger->coaphase[data->ifo_mapping] = atan2(this_snr.im, this_snr.im*this_snr.re);
			GST_DEBUG_OBJECT(jointer, "new ifos -> %s, this ifo %d, sample %d, tmplt_idx %d,"
					"new ifo snr.re %f, snr.im %f, snr %f", trigger->ifos, data->ifo_mapping, 
					this_sample, tmplt_idx, this_snr.re, this_snr.im, 
					sqrt(this_snr.re*this_snr.re + this_snr.im*this_snr.im));
		}
	}
	return ret;
}


static GstFlowReturn
trigger_jointer_process(GstCollectPads *pads,
		TriggerJointer *jointer) {
	GSList *collectlist;
	TriggerJointerCollectData *data;
    GstBuffer *buf = NULL, *postcoh_buf = NULL;
    GstFlowReturn ret = GST_FLOW_OK;
	gboolean is_gap;
	GstClockTime buf_start, buf_end;

	int i;
	/* 
	 * first, load the postcoh_buf pointer with the buffer from the postcoh pad;
	 * load each snr adapter with the snr buf from each snr pad
	 */
    for (i = 0, collectlist = pads->data; collectlist;
         collectlist = g_slist_next(collectlist), i++) {
        data = collectlist->data;
        buf  = gst_collect_pads_pop(pads, (GstCollectData *)data);
		/* no buffer in postcoh pad, sending EOS event downstream */
		if (!buf && data->is_snr == 0)  {
			ret = gst_pad_push_event(jointer->srcpad, gst_event_new_eos());
			return ret;
		}
		/* no buffer in SNR pad, do nothing */
		if (!buf && data->is_snr == 1) 
			continue;

		/* has postcoh buffer */
        if (buf && data->is_snr == 0) { 
			jointer->is_next_tstart_set = FALSE;
			postcoh_buf = buf;
		} else {/* has snr buffer, add flag segment and push to adapter and */
            is_gap =
              GST_BUFFER_FLAG_IS_SET(buf, GST_BUFFER_FLAG_GAP) ? TRUE : FALSE;
			buf_start = GST_BUFFER_TIMESTAMP(buf);
			buf_end = buf_start + GST_BUFFER_DURATION(buf);
            add_flag_segment(data, buf_start, buf_end, is_gap);
			gst_adapter_push(data->adapter, buf);
			GST_DEBUG_OBJECT(jointer, "snr buffer pushed to adapter, is gap %d", is_gap);
		}
	}
	/* append coincidence snr from the snr buffer for each postcoh trigger */
    ret = trigger_jointer_append_coinc_snr(jointer, postcoh_buf);

    if (ret != GST_FLOW_OK) {
        fprintf(
          stderr,
          "failed to append coinc snr");
			return ret;
    }
	/* push the processed tabel downstream */ 
    ret = gst_pad_push(jointer->srcpad, postcoh_buf);

    if (ret != GST_FLOW_OK) {
        fprintf(
          stderr,
          "failed to push buffer to next element finalsink");
			return ret;
    }

    GST_LOG_OBJECT(jointer, "pushed buffer, result = %s",
                   gst_flow_get_name(ret));

	return ret;
}

/* entry function */
static GstFlowReturn collected(GstCollectPads *pads, gpointer user_data) {
    TriggerJointer *jointer = TRIGGER_JOINTER(user_data);

    GstElement *element = GST_ELEMENT(jointer);
    GstClockTime tstart, tend;
    GstFlowReturn ret = GST_FLOW_OK;
    guint64 offset_start = 0;

    GST_DEBUG_OBJECT(jointer, "collected");
    /* Make sure that we have enough sink pads. At least 2, one for the postcoh pad,
	 * the others for snr pads */
    if (element->numsinkpads < 2) {
        GST_ERROR_OBJECT(
          jointer, "not enough sink pads, 2 required but only %d are present",
          element->numsinkpads < 2);
        return GST_FLOW_ERROR;
    }

    if (!jointer->is_t0_set) {
		/* 
		 * Initialization. Set the start time t0 from the latest time
		 * of any pads, whether the postcoh pad or snr pads.
		 * and get the snr sample rate information from snr pads.
		 */
        /* get the timestamp for start and end from the postcoh table buffer */
        if (!trigger_jointer_get_start_end_time(jointer, &tstart, &tend,
                                                &offset_start)) {
            /* bad buffer : one of the buffers is at EOS or invalid timestamp/
             * offset */
            GST_ERROR_OBJECT(
              jointer, "cannot deduce start timestamp/ offset information");
            return GST_FLOW_ERROR;
        }
        jointer->t0           = tstart;
		jointer->tstart       = tstart;
        jointer->next_tstart   = tend;
        jointer->offset0      = offset_start;
		jointer->is_next_tstart_set = TRUE;
        GST_DEBUG_OBJECT(jointer,
                         "set the aligned time t0 to %" GST_TIME_FORMAT
                         ", start offset0 to %" G_GUINT64_FORMAT,
                         GST_TIME_ARGS(jointer->t0), jointer->offset0);
        jointer->is_t0_set = TRUE;
		/* get the width, rate, channel information from the caps structure of each snr pad */
		trigger_jointer_set_snr_info(jointer);
    }

    if (!jointer->is_all_aligned) {
		/* 
		 * Align the snr pads to the postcoh pad according to t0. 
		 * Throw away those buffers from the snr pads whose start timestamps are less than t0.
		 * When this condition is satisfied, we can start process the triggers.
		 */
        jointer->is_all_aligned = trigger_jointer_align_collected(pads, jointer);
    } else {
        if (!jointer->is_next_tstart_set){
			/* set the next start time and end time from the postcoh pad */
			trigger_jointer_set_next_tstart(pads, jointer);
			jointer->is_next_tstart_set = TRUE;
		}
        if (trigger_jointer_need_recollect(pads, jointer)) 
			/* snr pad does not have enough buffers to cover expected end time,
			 * recollect buffers */
			return GST_FLOW_OK;
		/* process, append each trigger with coinc snr and push downstream */
        ret = trigger_jointer_process(pads, jointer);
    }
    return ret;
}

/* no set caps */

/* no set properties */

/* initialization */

static void trigger_jointer_dispose(GObject *object) {
    TriggerJointer *element = TRIGGER_JOINTER(object);
    if (element->collect) gst_object_unref(GST_OBJECT(element->collect));
    element->collect = NULL;

    if (element->srcpad) gst_object_unref(element->srcpad);
    element->srcpad = NULL;
    /* destroy hashtable and its contents */
    G_OBJECT_CLASS(parent_class)->dispose(object);
}

static void trigger_jointer_base_init(gpointer g_class) {
    GstElementClass *element_class = GST_ELEMENT_CLASS(g_class);

    gst_element_class_set_details_simple(
      element_class, "Populate postcoh table with maximum coincident SNRs from postcoh-bypassed detectors", "Filter",
      "Trigger Jointer.\n", "Qi Chu <qi.chu at ligo dot org>");

	/* sink pads */
    gst_element_class_add_pad_template(
      element_class, gst_static_pad_template_get(&trigger_jointer_postcoh_sink_template));
    gst_element_class_add_pad_template(
      element_class, gst_static_pad_template_get(&trigger_jointer_snr_sink_template));
	/* src pads */
    gst_element_class_add_pad_template(
      element_class,
      gst_pad_template_new("src", GST_PAD_SRC, GST_PAD_ALWAYS,
                           gst_caps_from_string("application/x-lal-postcoh")));
}

static void trigger_jointer_class_init(TriggerJointerClass *klass) {
    GObjectClass *gobject_class       = G_OBJECT_CLASS(klass);
    GstElementClass *gstelement_class = GST_ELEMENT_CLASS(klass);

    parent_class = g_type_class_ref(GST_TYPE_ELEMENT);

    gobject_class->dispose      = GST_DEBUG_FUNCPTR(trigger_jointer_dispose);
    gstelement_class->request_new_pad =
      GST_DEBUG_FUNCPTR(trigger_jointer_request_new_pad);
    gstelement_class->release_pad = GST_DEBUG_FUNCPTR(trigger_jointer_release_pad);
    gstelement_class->change_state =
      GST_DEBUG_FUNCPTR(trigger_jointer_change_state);
}

static void trigger_jointer_init(TriggerJointer *jointer, TriggerJointerClass *klass) {
    GstElement *element = GST_ELEMENT(jointer);

    gst_element_create_all_pads(element);
    jointer->srcpad = gst_element_get_static_pad(element, "src");
    GST_DEBUG_OBJECT(jointer, "%s caps %" GST_PTR_FORMAT,
                     GST_PAD_NAME(jointer->srcpad),
                     gst_pad_get_caps(jointer->srcpad));

    gst_pad_set_event_function(jointer->srcpad, GST_DEBUG_FUNCPTR(src_event));
    jointer->collect = gst_collect_pads_new();
    gst_collect_pads_set_function(jointer->collect,
                                  GST_DEBUG_FUNCPTR(collected), jointer);

    jointer->t0         = GST_CLOCK_TIME_NONE;
    jointer->tstart = GST_CLOCK_TIME_NONE;
    jointer->next_tstart = GST_CLOCK_TIME_NONE;
    jointer->offset0    = GST_BUFFER_OFFSET_NONE;

    jointer->is_t0_set  = FALSE;
    jointer->is_all_aligned = FALSE;
    jointer->is_next_tstart_set = FALSE;
}
